<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the Configuration class
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 *
 * @uses ezcPhpGenerator To generate INI cache
 */

namespace eZ\Publish\Core\Base;
use eZ\Publish\Core\Base\Configuration\Parser,
    eZ\Publish\Core\Base\Exception\BadConfiguration,
    eZ\Publish\Core\Base\Exception\InvalidArgumentValue,
    ezcPhpGenerator;

/**
 * Configuration instance class
 *
 * A configuration class with override setting support that uses parsers to deal with
 * files so you can support ini/yaml/xml/json given it is defined when setting up the class.
 *
 * By default values are cached to a raw php files and files are not read again unless
 * development mode is on and some file has been removed or modified since cache was created.
 *
 * @uses \ezcPhpGenerator When generating cache files.
 */
class Configuration
{
    /**
     * Constant path to directory for configuration cache
     *
     * @var string
     */
    const CONFIG_CACHE_DIR = 'var/cache/ini/';

    /**
     * Constant string used as a temporary unset variable during ini parsing
     *
     * @var string
     */
    const TEMP_INI_UNSET_VAR = '__UNSET__';

    /**
     * Constant integer to check against configuration cache format revision
     *
     * @var int
     */
    const CONFIG_CACHE_REV = 3;

    /**
     * The instance path array, scoped in the order they should be parsed
     *
     * @var array
     */
    private $paths = array();

    /**
     * The instance configuration path array md5 hash, for use in cache names.
     * Empty if it needs to be regenerated
     *
     * @var string
     */
    private $pathsHash = '';

    /**
     * The instance module name, set by {@link __construct()}
     *
     * @var string
     */
    protected $moduleName = null;

    /**
     * The in memory representation of the current raw configuration data.
     *
     * @var null|array
     */
    protected $raw = null;

    /**
     * Global settings (see config.php-RECOMMENDED)
     *
     * @var array
     */
    protected $globalConfiguration;

    /**
     * @var int
     */
    protected $filePermission = 0644;

    /**
     * @var int
     */
    protected $dirPermission = 0755;

    /**
     * Create instance of Configuration
     *
     * @param string $moduleName The name of the module (and in case of ini files, same as ini filename w/o suffix)
     * @param array $paths Paths to look for settings in.
     * @param array $globalConfiguration Global settings for module
     */
    public function __construct( $moduleName = 'base', array $paths, array $globalConfiguration )
    {
        $this-&gt;moduleName = $moduleName;
        $this-&gt;paths = $paths;
        $this-&gt;globalConfiguration = $globalConfiguration;

        if ( isset( $globalConfiguration['base']['Configuration']['CacheFilePermission'] ) )
            $this-&gt;filePermission = $globalConfiguration['base']['Configuration']['CacheFilePermission'];

        if ( isset( $globalConfiguration['base']['Configuration']['CacheDirPermission'] ) )
            $this-&gt;dirPermission = $globalConfiguration['base']['Configuration']['CacheDirPermission'];
    }

    /**
     * Get raw instance override path list data.
     *
     * @throws InvalidArgumentValue If scope has wrong value
     * @param string $scope See {@link $globalPaths} for scope values (first level keys)
     * @return array
     */
    public function getDirs( $scope = null )
    {
        if ( $scope === null )
            return $this-&gt;paths;
        if ( !isset( $this-&gt;paths[$scope] ) )
            throw new InvalidArgumentValue( 'scope', $scope, get_class( $this ) );

        return $this-&gt;paths[$scope];
    }

    /**
     * Get cache hash based on override dirs
     *
     * @return string md5 hash
     */
    protected function pathsHash()
    {
        if ( $this-&gt;pathsHash === '' )
        {
            $this-&gt;pathsHash = md5( serialize( $this-&gt;paths ) );
        }
        return $this-&gt;pathsHash;
    }

    /**
     * Reload cache data conditionally if path hash has changed on current instance
     */
    public function reload()
    {
        if ( !isset( $this-&gt;raw['hash'] ) || $this-&gt;raw['hash'] !== $this-&gt;pathsHash() )
            $this-&gt;load();
    }

    /**
     * Load the configuration from cache or from source (if $useCache is false or there is no cache)
     *
     * @param bool|null $hasCache Lets you specify if there is a cache file, will check if null and $useCache is true
     * @param bool $useCache Will skip using cached config files (slow), when null depends on [ini]\use-cache setting
     */
    public function load( $hasCache = null, $useCache = null )
    {
        $cacheName = $this-&gt;createCacheName( $this-&gt;pathsHash() );
        if ( $useCache === null )
        {
            $useCache =
                isset( $this-&gt;globalConfiguration['base']['Configuration']['UseCache'] )
                ? $this-&gt;globalConfiguration['base']['Configuration']['UseCache']
                : false;
        }

        if ( $hasCache === null &amp;&amp; $useCache )
        {
            $hasCache = $this-&gt;hasCache( $cacheName );
        }

        if ( $hasCache &amp;&amp; $useCache )
        {
            $this-&gt;raw = $this-&gt;readCache( $cacheName );
            $hasCache = $this-&gt;raw !== null;
        }

        if ( !$hasCache )
        {
            $sourceFiles = array();
            $configurationData = $this-&gt;parse( $this-&gt;getDirs(), $sourceFiles );
            $this-&gt;raw = $this-&gt;generateRawData( $this-&gt;pathsHash(), $configurationData, $sourceFiles, $this-&gt;getDirs() );

            if ( $useCache )
            {
                $this-&gt;storeCache( $cacheName, $this-&gt;raw );
            }
        }

        // Merge global settings (not cached as they are runtime settings)
        if ( !isset( $this-&gt;globalConfiguration[ $this-&gt;moduleName ] ) )
            return;

        foreach ( $this-&gt;globalConfiguration[ $this-&gt;moduleName ] as $section =&gt; $settings )
        {
            if ( !isset( $this-&gt;raw['data'][$section] ) )
            {
                $this-&gt;raw['data'][$section] = $settings;
                continue;
            }

            foreach ( $settings as $setting =&gt; $value )
            {
                $this-&gt;raw['data'][$section][$setting] = $value;
            }
        }
    }

    /**
     * Create cache name.
     *
     * @param string $configurationPathsHash
     * @return string
     */
    protected function createCacheName( $configurationPathsHash )
    {
        return $this-&gt;moduleName . '-' . $configurationPathsHash;
    }

    /**
     * Check if cache file exists.
     *
     * @param string $cacheName As generated by {@link createCacheName()}
     * @return boolean
     */
    protected function hasCache( $cacheName )
    {
        return file_exists( self::CONFIG_CACHE_DIR . $cacheName . '.php' );
    }

    /**
     * Load cache file, use {@link hasCache()} to make sure it exists first!
     *
     * @param string $cacheName As generated by {@link createCacheName()}
     * @return array|null
     */
    protected function readCache( $cacheName )
    {
        $cacheData = include self::CONFIG_CACHE_DIR . $cacheName . '.php';

        // Check that cache has
        if ( !isset( $cacheData['data'] ) || $cacheData['rev'] !== self::CONFIG_CACHE_REV )
        {
            return null;
        }

        // Check modified time if dev mode
        if ( isset( $this-&gt;globalConfiguration['base']['Configuration']['DevelopmentMode'] )
          &amp;&amp; $this-&gt;globalConfiguration['base']['Configuration']['DevelopmentMode'] )
        {
            $currentTime = time();
            foreach ( $cacheData['files'] as $inputFile )
            {
                $fileTime = file_exists( $inputFile ) ? filemtime( $inputFile ) : false;
                // Refresh cache &amp; input files if file is gone
                if ( $fileTime === false )
                {
                    return null;
                }
                if ( $fileTime &gt; $currentTime )
                {
                    trigger_error( __METHOD__ . ': Input file &quot;' . $inputFile . '&quot; has a timestamp higher then current time, ignoring to avoid infinite recursion!', E_USER_WARNING );
                }
                // Refresh cache if file has been changed
                else if ( $fileTime &gt; $cacheData['created'] )
                {
                    return null;
                }
            }
        }
        return $cacheData;
    }

    /**
     * Generate raw data for use in cache
     *
     * @param string $configurationPathsHash
     * @param array $configurationData
     * @param array $sourceFiles Optional, stored in cache to be able to check modified time in future devMode
     * @param array $sourcePaths Optional, stored in cache to be able to debug it more easily
     */
    protected function generateRawData( $configurationPathsHash, array $configurationData, array $sourceFiles = array(), array $sourcePaths = array() )
    {
        return array(
            'hash' =&gt; $configurationPathsHash,
            'paths' =&gt; $sourcePaths,
            'files' =&gt; $sourceFiles,
            'data' =&gt; $configurationData,
            'created' =&gt; time(),
            'rev' =&gt; self::CONFIG_CACHE_REV,
        );
    }

    /**
     * Parse configuration files
     *
     * @param array $configurationPaths
     * @param array $sourceFiles ByRef value or source files that has been/is going to be parsed
     *                           files you pass in will not be checked if they exists.
     * @return array Data structure for parsed ini files
     * @throws eZ\Publish\Core\Base\Exception\BadConfiguration If no parser have been defined
     */
    protected function parse( array $configurationPaths, array &amp;$sourceFiles )
    {
        if ( empty( $this-&gt;globalConfiguration['base']['Configuration']['Parsers'] ) )
        {
            throw new BadConfiguration( 'base\[Configuration]\Parsers', 'Could not parse configuration files' );
        }
        $parsers = $this-&gt;globalConfiguration['base']['Configuration']['Parsers'];
        foreach ( $configurationPaths as $scopeArray )
        {
            foreach ( $scopeArray as $settingsDir )
            {
                foreach ( $parsers as $suffix =&gt; $parser )
                {
                    $fileName = $settingsDir . $this-&gt;moduleName . $suffix;
                    if ( !isset( $sourceFiles[$fileName] ) &amp;&amp; file_exists( $fileName ) )
                    {
                        $sourceFiles[$fileName] = $suffix;
                    }
                }
            }
        }

        // No source files, no configuration
        if ( empty( $sourceFiles ) )
        {
            return array();
        }

        $configurationData = array();
        $configurationFileData = array();
        foreach ( $sourceFiles as $fileName =&gt; $suffix )
        {
            if ( !$parsers[$suffix] instanceof Parser )
                $parsers[$suffix] = new $parsers[$suffix]( $this-&gt;globalConfiguration );

            $configurationFileData[$fileName] = $parsers[$suffix]-&gt;parse( $fileName, file_get_contents( $fileName ) );
        }

        // Post processing to unset array self::TEMP_INI_UNSET_VAR values as set by parser to indicate array clearing
        // and to merge configuration data from all configuration files
        foreach ( $configurationFileData as $file =&gt; $data )
        {
            foreach ( $data as $section =&gt; $sectionArray )
            {
                if ( !isset( $configurationData[$section] ) )
                    $configurationData[$section] = array();

                $this-&gt;recursiveArrayClearing( $sectionArray, $configurationData[$section] );
            }
        }

        return $configurationData;
    }

    /**
     * Recursively clear array values
     *
     * @param array $iniArray
     * @param array|null $configurationPiece
     */
    protected function recursiveArrayClearing( array $iniArray, &amp;$configurationPiece )
    {
        foreach ( $iniArray as $setting =&gt; $settingValue )
        {
            if ( isset( $settingValue[0] ) &amp;&amp; $settingValue[0] === self::TEMP_INI_UNSET_VAR )
            {
                array_shift( $settingValue );
                $configurationPiece[$setting] = $settingValue;
            }
            elseif ( is_array( $settingValue ) )
            {
                $this-&gt;recursiveArrayClearing( $settingValue, $configurationPiece[$setting] );
            }
            else
            {
                $configurationPiece[$setting] = $settingValue;
            }
        }

    }

    /**
     * Store cache file, overwrites any existing file
     *
     * @param string $cacheName As generated by {@link createCacheName()}
     * @param array $rawData As generated by {@link generateRawData()}
     */
    protected function storeCache( $cacheName, array $rawData )
    {
        try
        {
            // Create ini dir if it does not exist
            if ( !file_exists( self::CONFIG_CACHE_DIR ) )
            {
                mkdir( self::CONFIG_CACHE_DIR, $this-&gt;dirPermission, true );
            }

            // Create cache hash
            $cachedFile = self::CONFIG_CACHE_DIR . $cacheName . '.php';

            // Store cache
            $generator = new ezcPhpGenerator( $cachedFile );
            $generator-&gt;appendComment( &quot;This file is auto generated based on configuration files for '{$this-&gt;moduleName}' module. Do not edit!&quot; );
            $generator-&gt;appendComment( &quot;Time created (server time): &quot; . date( DATE_RFC822, $rawData['created'] ) );
            $generator-&gt;appendEmptyLines();

            $generator-&gt;appendValueAssignment( 'cacheData', $rawData );
            $generator-&gt;appendCustomCode( 'return $cacheData;' );

            $generator-&gt;finish();

            // make sure file has correct file permissions
            chmod( $cachedFile, $this-&gt;filePermission );
        }
        catch ( Exception $e )
        {
            // constructor     : ezcBaseFileNotFoundException or ezcBaseFilePermissionException
            // all other calls : ezcPhpGeneratorException
            trigger_error( __METHOD__ . ': '. $e-&gt;getMessage(), E_USER_WARNING );
        }
    }

    /**
     * Gets a configuration value, or $fallBackValue if undefined
     * Triggers warning if key is not set and $fallBackValue is null
     *
     * @param string $section The configuration section to get value for
     * @param string $key The configuration key to get value for
     * @param mixed $fallBackValue value to return if setting is undefined.
     * @return mixed|null (null if key is undefined and no $fallBackValue is provided)
     */
    public function get( $section, $key, $fallBackValue = null )
    {
        if ( isset( $this-&gt;raw['data'][$section][$key] ) )
        {
            return $this-&gt;raw['data'][$section][$key];
        }
        if ( $fallBackValue === null )
        {
            trigger_error( __METHOD__ . &quot; could not find {$this-&gt;moduleName}.ini\[{$section}]$key setting&quot;, E_USER_WARNING );
        }
        return $fallBackValue;
    }

    /**
     * Gets a configuration values for a section or $fallBackValue if undefined
     * Triggers warning if section is not set and $fallBackValue is null
     *
     * @param string $section The configuration section to get value for
     * @param mixed $fallBackValue value to return if section is undefined.
     * @return array|null (null if key is undefined and no $fallBackValue is provided)
     */
    public function getSection( $section, $fallBackValue = null )
    {
        if ( isset( $this-&gt;raw['data'][$section] ) )
        {
            return $this-&gt;raw['data'][$section];
        }
        if ( $fallBackValue === null )
        {
            trigger_error( __METHOD__ . &quot; could not find {$this-&gt;moduleName}.ini\[{$section}]setting&quot;, E_USER_WARNING );
        }
        return $fallBackValue;
    }

    /**
     * Gets all section and configuration value
     *
     * @return array
     */
    public function getAll()
    {
        return $this-&gt;raw['data'];
    }

    /**
     * Gets a configuration value, or null if not set.
     *
     * @param string $section The configuration section to get value for
     * @param string $key The configuration key to get value for
     * @param mixed $value value to return if setting is not defined.
     * @return bool Return true if section existed and was overwritten
     */
    public function set( $section, $key, $value = null )
    {
        if ( isset( $this-&gt;raw['data'][$section] ) )
        {
            $this-&gt;raw['data'][$section][$key] = $value;
            return true;
        }

        $this-&gt;raw['data'][$section] = array( $key =&gt; $value );
        return false;
    }

    /**
     * Checks if a configuration section and optionally key is set.
     *
     * @param string $section
     * @param string $key Optional, only checks if section exists if null
     * @return bool Return true if setting exist
     */
    public function has( $section, $key = null )
    {
        if ( $key === null )
            return isset( $this-&gt;raw['data'][$section] );

        return isset( $this-&gt;raw['data'][$section][$key] );
    }

    /**
     * Checks if a configuration section &amp; key is set and has a value.
     * (ie. a check using !empty())
     *
     * @param string $section
     * @param string $key
     * @return bool Return true if setting exist and has value
     */
    public function hasValue( $section, $key )
    {
        return !empty( $this-&gt;raw['data'][$section][$key] );
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>