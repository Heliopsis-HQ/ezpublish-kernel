<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File contains Configuration Ini Parser / writer
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 *
 * @uses ezcConfiguration As fallback if parse_ini_string() fails
 */

namespace eZ\Publish\Core\Base\Configuration\Parser;
use eZ\Publish\Core\Base\Configuration,
    eZ\Publish\Core\Base\Configuration\Parser,
    eZ\Publish\Core\Base\Exception\Logic,
    ezcConfiguration,
    ezcConfigurationIniReader;

/**
 * Configuration Ini Parser / writer
 */
class Ini implements Parser
{
    /**
     * Constant string used as a temporary true variable during ini parsing to avoid
     * parse_ini_file from casting it to 1
     *
     * @var string
     */
    const TEMP_INI_TRUE_VAR = '__TRUE__';

    /**
     * Constant string used as a temporary false variable during ini parsing to avoid
     * parse_ini_file from casting it to 0
     *
     * @var string
     */
    const TEMP_INI_FALSE_VAR = '__FALSE__';

    /**
     * Constant string used as a temporary array key separator when merging several dimensions
     * for php_ini_string support, {@see parsePhpPostArrayFilter()} &amp; {@see parserPhpDimensionArraySupport()}
     *
     * @var string
     */
    const TEMP_INI_KEY_VAR = '__KEY__';

    /**
     * Defines if strict mode should be used (parse_ini_string), otherwise use ezcConfigurationIniReader
     *
     * @var boolean
     */
    protected $strictMode = false;

    /**
     * @var int
     */
    protected $filePermission = 0644;

    /**
     * @var int
     */
    protected $dirPermission = 0755;

    /**
     * Construct an instance of Ini Parser
     *
     * @param array $globalConfiguration
     */
    public function __construct( array $globalConfiguration )
    {
        if ( isset( $globalConfiguration['base']['Configuration']['IniParserStrict'] ) )
            $this-&gt;strictMode = $globalConfiguration['base']['Configuration']['IniParserStrict'];

        if ( isset( $globalConfiguration['base']['Configuration']['CacheFilePermission'] ) )
            $this-&gt;filePermission = $globalConfiguration['base']['Configuration']['CacheFilePermission'];

        if ( isset( $globalConfiguration['base']['Configuration']['CacheDirPermission'] ) )
            $this-&gt;dirPermission = $globalConfiguration['base']['Configuration']['CacheDirPermission'];
    }

    /**
     * Parse file and return raw configuration data
     *
     * @todo Change impl to use exceptions instead of trigger_error in most cases
     *
     * @param string $fileName A valid file name
     * @param string $fileContent
     * @return array
     */
    public function parse( $fileName, $fileContent )
    {
        if ( !$this-&gt;strictMode )
        {
            return $this-&gt;parseFileEzc( $fileContent );
        }

        $configurationData = $this-&gt;parseFilePhp( $fileContent );
        if ( $configurationData === false )
        {
            trigger_error(
                &quot;parse_ini_string( {$fileName} ) failed, see warning for line number. &quot;,
                E_USER_NOTICE
            );
            return array();
        }
        return $configurationData;
    }

    /**
     * Parse configuration file using parse_ini_string (only supported on php 5.3 and up)
     *
     * This parser is stricter then ezcConfigurationIniReader and does not support many of
     * the ini files eZ Publish use because things like regex as ini variable and so on.
     *
     * @param string $fileContent
     * @return array|false Data structure for parsed ini file or false if it fails
     */
    protected function parseFilePhp( $fileContent )
    {
        // First some pre processing to normalize result with ezc result (avoid 'true' becoming '1')
        $fileContent = str_replace(
            array( '#', &quot;\r\n&quot;, &quot;\r&quot;, &quot;=true\n&quot;, &quot;=false\n&quot; ),
            array( ';', &quot;\n&quot;, &quot;\n&quot;, &quot;=&quot; . self::TEMP_INI_TRUE_VAR . &quot;\n&quot;, &quot;=&quot; . self::TEMP_INI_FALSE_VAR . &quot;\n&quot; ),
            $fileContent . &quot;\n&quot;
        );
        $fileContent = $this-&gt;parserPhpDimensionArraySupport( $fileContent );
        $fileContent = $this-&gt;parserClearArraySupport( $fileContent );

        // Parse string
        $configurationData = parse_ini_string( $fileContent, true );

        // Post processing to turn en/disabled back to bool values (like ezc parser does for true/false strings)
        // cast numeric values and unset array self::TEMP_INI_UNSET_VAR values as set in {@link self::parserClearArraySupport()}
        if ( $configurationData === false )
        {
            return $configurationData;
        }

        foreach ( $configurationData as $section =&gt; $sectionArray )
        {
            foreach ( $sectionArray as $setting =&gt; $settingValue )
            {
                if ( is_array( $settingValue ) )
                {
                    $configurationData[$section][$setting] = self::parsePhpPostArrayFilter( $configurationData[$section][$setting] );
                }
                else
                {
                    $configurationData[$section][$setting] = self::parsePhpPostFilter( $settingValue );
                }
            }
        }
        return $configurationData;
    }

    /**
     * Parse configuration file using ezcConfigurationIniReader
     *
     * @todo Change impl to use exceptions instead of trigger_error
     *
     * @param string $fileContent
     * @return array Data structure for parsed ini file
     */
    protected function parseFileEzc( $fileContent )
    {
        // First some pre processing to normalize result with parse_ini_string result
        $fileContent = str_replace( array( &quot;\r\n&quot;, &quot;\r&quot; ), &quot;\n&quot;, $fileContent . &quot;\n&quot; );
        $fileContent = preg_replace( array( '/^&lt;\?php[^\/]\/\*\s*/', '/\*\/[^\?]\?&gt;/' ), '', $fileContent );
        $fileContent = $this-&gt;parserClearArraySupport( $fileContent );

        // Create ini dir if it does not exist
        if ( !file_exists( Configuration::CONFIG_CACHE_DIR ) )
            mkdir( Configuration::CONFIG_CACHE_DIR, $this-&gt;dirPermission, true );

        // Create temp file
        $tempFileName = Configuration::CONFIG_CACHE_DIR . 'temp-' . mt_rand() . '.tmp.ini';
        if ( file_put_contents( $tempFileName, $fileContent ) === false )
        {
            trigger_error( __METHOD__ . &quot;: temporary ini file ($tempFileName) needed for ini parsing not writable!&quot;, E_USER_WARNING );
            return array();
        }

        // Parse string
        try
        {
            $reader = new ezcConfigurationIniReader( $tempFileName );
            $configuration = $reader-&gt;load();
        }
        catch ( Exception $e)
        {
            trigger_error( __METHOD__ . ': Caught exception: ' .  $e-&gt;getMessage() . &quot; \n[&quot; . $e-&gt;getFile() . ' (' . $e-&gt;getLine() . ')]', E_USER_WARNING );
        }

        $configurationData = array();
        $result = $reader-&gt;validate();
        if ( !$result-&gt;isValid )
        {
            foreach ( $result-&gt;getResultList() as $resultItem )
            {
                 trigger_error( __METHOD__ . ': ezc parser error in ' . $resultItem-&gt;file . ':' . $resultItem-&gt;line . ':' . $resultItem-&gt;column. ': ' . $resultItem-&gt;details, E_USER_WARNING );
            }
        }
        else if ( $configuration instanceof ezcConfiguration )
        {
            $configurationData = $configuration-&gt;getAllSettings();
            foreach ( $configurationData as $section =&gt; $sectionArray )
            {
                foreach ( $sectionArray as $setting =&gt; $value )
                {
                    // fix appending ##! and such lines
                    if ( isset( $value[0] ) &amp;&amp; is_string( $value ) &amp;&amp; strpos( $value, '#' ) !== false )
                    {
                        $value = explode( '#', $value );
                        $configurationData[$section][$setting] = $value[0];
                    }
                }
            }
        }
        else
        {
            trigger_error( __METHOD__ . ': $configuration not instanceof ezcConfiguration', E_USER_WARNING );
        }
        // Remove temp file
        unlink( $tempFileName );
        return $configurationData;
    }

    /**
     * Pre processing needed for php ini parsers to support three dimensional arrays
     *
     * Injects constants which is later cleaned up in {@link parsePhpPostArrayFilter()}.
     *
     * @param string $fileContent
     * @return string
     */
    protected function parserPhpDimensionArraySupport( $fileContent )
    {
        if ( preg_match_all( &quot;/^([\w_-]+)\[([\w_-]+)?\]\[([\w_-]+)?\](\[([\w_-]+)?\])?/m&quot;, $fileContent, $valueArray, PREG_OFFSET_CAPTURE ) )
        {
            $offsetDiff = 0;// Since we use offset captured before replace operations, we need to maintain an offset diff
            foreach ( $valueArray[0] as $key =&gt; $match )
            {
                // Variable name
                $replaceString = $valueArray[1][$key][0] . '[';

                // If first key is empty use $key to make it unique
                if ( empty( $valueArray[2][$key][0] ) )
                    $replaceString .= $key;
                else
                    $replaceString .= $valueArray[2][$key][0];

                // Add key separator
                $replaceString .= self::TEMP_INI_KEY_VAR;

                // If second key is empty use $key to make it unique
                if ( empty( $valueArray[3][$key][0] ) )
                    $replaceString .= $key;
                else
                    $replaceString .= $valueArray[3][$key][0];

                if ( !empty( $valueArray[4][$key][0] ) )
                {
                    $replaceString .= self::TEMP_INI_KEY_VAR;
                    if ( empty( $valueArray[5][$key][0] ) )
                        $replaceString .= $key;
                    else
                        $replaceString .= $valueArray[5][$key][0];
                }

                $replaceString .= ']';

                $fileContent = substr_replace( $fileContent, $replaceString, $match[1] + $offsetDiff, strlen( $match[0] ) );
                $offsetDiff += strlen( $replaceString ) - strlen( $match[0] );
            }
        }
        return $fileContent;
    }

    /**
     * Transform temporary values the php equivalent to make sure parsed ini settings
     * are the same as with ezcConfigurationIniReader.
     *
     * @param mixed $iniValue
     * @return mixed
     */
    protected static function parsePhpPostFilter( $iniValue )
    {
        if ( $iniValue === self::TEMP_INI_TRUE_VAR )
            return true;

        if ( $iniValue === self::TEMP_INI_FALSE_VAR )
            return false;

        if ( is_numeric( $iniValue ) )
        {
            if ( strpos( $iniValue, '.' ) !== false )
                return (float)$iniValue;

            return (int)$iniValue;
        }

        if ( isset( $iniValue[1] ) &amp;&amp; is_string( $iniValue ) )
            return rtrim( $iniValue, ' ' );

        return $iniValue;
    }

    /**
     * Transform temporary array values the php equivalent to make sure parsed ini settings
     * are the same as with ezcConfigurationIniReader.
     *
     * Deals specifically with post parse fixes for three dimensional arrays.
     *
     * @param array $array
     * @return array
     */
    protected static function parsePhpPostArrayFilter( array $array )
    {
        $newArray = array();
        foreach ( $array as $key =&gt; $value )
        {
            if ( strpos( $key, self::TEMP_INI_KEY_VAR ) !== false )
            {
                $keys = explode( self::TEMP_INI_KEY_VAR, $key );
                if ( is_numeric( $keys[0] ) )
                {
                    if ( is_numeric( $keys[1] ) )
                    {
                        if ( isset( $keys[2] ) &amp;&amp; is_numeric( $keys[2] ) )
                            $newArray[][][] = self::parsePhpPostFilter( $value );
                        elseif ( isset( $keys[2] ) )
                            $newArray[][][$keys[2]] = self::parsePhpPostFilter( $value );
                        else
                            $newArray[][] = self::parsePhpPostFilter( $value );
                    }
                    else
                    {
                        if ( isset( $keys[2] ) &amp;&amp; is_numeric( $keys[2] ) )
                            $newArray[][$keys[1]][] = self::parsePhpPostFilter( $value );
                        elseif ( isset( $keys[2] ) )
                            $newArray[][$keys[1]][$keys[2]] = self::parsePhpPostFilter( $value );
                        else
                            $newArray[][$keys[1]] = self::parsePhpPostFilter( $value );
                    }
                }
                else
                {
                    if ( is_numeric( $keys[1] ) )
                    {
                        if ( isset( $keys[2] ) &amp;&amp; is_numeric( $keys[2] ) )
                            $newArray[$keys[0]][][] = self::parsePhpPostFilter( $value );
                        elseif ( isset( $keys[2] ) )
                            $newArray[$keys[0]][][$keys[2]] = self::parsePhpPostFilter( $value );
                        else
                            $newArray[$keys[0]][] = self::parsePhpPostFilter( $value );
                    }
                    else
                    {
                        if ( isset( $keys[2] ) &amp;&amp; is_numeric( $keys[2] ) )
                            $newArray[$keys[0]][$keys[1]][] = self::parsePhpPostFilter( $value );
                        elseif ( isset( $keys[2] ) )
                            $newArray[$keys[0]][$keys[1]][$keys[2]] = self::parsePhpPostFilter( $value );
                        else
                            $newArray[$keys[0]][$keys[1]] = self::parsePhpPostFilter( $value );
                    }
                }
            }
            else
            {
                $newArray[ $key ] = self::parsePhpPostFilter( $value );
            }
        }
        return $newArray;
    }

    /**
     * Common pre processing needed for both ezc and php parsers
     *
     * Marks array clearing, so post parser code in {@link Configuration::parse()} can detect it
     *
     * @param string $fileContent
     * @return string
     */
    protected function parserClearArraySupport( $fileContent )
    {
        if ( preg_match_all( &quot;/^([\w_-]+)\[([\w_-]+)?\](\[([\w_-]+)?\])?$/m&quot;, $fileContent, $valueArray ) )
        {
            foreach ( $valueArray[0] as $variableArrayClearing )
            {
                $fileContent = str_replace( &quot;\n$variableArrayClearing\n&quot;, &quot;\n$variableArrayClearing=&quot; . Configuration::TEMP_INI_UNSET_VAR . &quot;\n&quot;, $fileContent );
            }
        }
        return $fileContent;
    }

    /**
     * Store raw configuration data to file
     *
     * @see eZ\Publish\Core\Base\Configuration\Parser::parse() For $configurationData definition
     * @todo Test..
     * @param string $fileName A valid file name, will be overwritten if it exists
     * @param array $configurationData
     */
    public function write( $fileName, array $configurationData )
    {
        if ( !is_writable( $fileName ) )
        {
            throw new Logic( &quot;{$fileName} is not writable&quot;, &quot;can not save configuration data!&quot; );
        }

        if ( strpos( $fileName, '.php', 1 ) !== false )
        {
            $iniStr = &quot;&lt;?php /* #?ini charset=\&quot;utf-8\&quot;?\n&quot;;
        }
        else
        {
            $iniStr = &quot;#?ini charset=\&quot;utf-8\&quot;?\n&quot;;
        }

        foreach ( $configurationData as $section =&gt; $sectionData )
        {
            $iniStr .= &quot;\n\n[{$section}]&quot;;
            foreach ( $sectionData as $var =&gt; $value )
            {
                if ( $value === true )
                {
                    $iniStr .= &quot;\n{$var}=true&quot;;
                }
                else if ( $value === false )
                {
                    $iniStr .= &quot;\n{$var}=false&quot;;
                }
                else if ( is_array( $value ) )
                {
                    if ( empty( $value ) )
                    {
                        $iniStr .= &quot;\n{$var}[]&quot;;
                        continue;
                    }
                    foreach ( $value as $arrayKey =&gt; $arrayValue )
                    {
                        if ( $arrayValue === Configuration::TEMP_INI_UNSET_VAR )
                        {
                            $iniStr .= &quot;\n{$var}[]&quot;;
                        }
                        else if ( is_string( $arrayKey ) )
                        {
                            $iniStr .= &quot;\n{$var}[{$arrayKey}]={$arrayValue}&quot;;
                        }
                        else
                        {
                            $iniStr .= &quot;\n{$var}[]={$arrayValue}&quot;;
                        }
                    }
                }
            }
        }
        file_put_contents( $fileName, $iniStr, LOCK_EX );
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>