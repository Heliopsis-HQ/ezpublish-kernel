<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the ContentHandler implementation
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 *
 */

namespace eZ\Publish\Core\Persistence\InMemory;
use eZ\Publish\SPI\Persistence\Content\Type\Handler as ContentTypeHandlerInterface,
    eZ\Publish\SPI\Persistence\Content\Type,
    eZ\Publish\SPI\Persistence\Content\Type\CreateStruct,
    eZ\Publish\SPI\Persistence\Content\Type\UpdateStruct,
    eZ\Publish\SPI\Persistence\Content\Type\FieldDefinition,
    eZ\Publish\SPI\Persistence\Content\Type\Group\CreateStruct as GroupCreateStruct,
    eZ\Publish\SPI\Persistence\Content\Type\Group\UpdateStruct as GroupUpdateStruct,
    eZ\Publish\SPI\Persistence\Content\Type\Group,
    ezp\Base\Exception\NotFound,
    ezp\Base\Exception\BadRequest,
    eZ\Publish\Core\Persistence\InMemory\Handler,
    eZ\Publish\Core\Persistence\InMemory\Backend,
    RuntimeException;

/**
 * @see \eZ\Publish\SPI\Persistence\Content\Type\Handler
 *
 * @todo Validate $status arguments
 */
class ContentTypeHandler implements ContentTypeHandlerInterface
{
    /**
     * @var Handler
     */
    protected $handler;

    /**
     * @var Backend
     */
    protected $backend;

    /**
     * Setups current handler instance with reference to Handler object that created it.
     *
     * @param Handler $handler
     * @param Backend $backend The storage engine backend
     */
    public function __construct( Handler $handler, Backend $backend )
    {
        $this-&gt;handler = $handler;
        $this-&gt;backend = $backend;
    }

    /**
     * @param \eZ\Publish\SPI\Persistence\Content\Type\Group\CreateStruct $group
     * @return \eZ\Publish\SPI\Persistence\Content\Type\Group
     */
    public function createGroup( GroupCreateStruct $group )
    {
        $groupArr = (array)$group;
        return $this-&gt;backend-&gt;create( 'Content\\Type\\Group', $groupArr );
    }

    /**
     * @param \eZ\Publish\SPI\Persistence\Content\Type\Group\UpdateStruct $group
     */
    public function updateGroup( GroupUpdateStruct $group )
    {
        $groupArr = (array)$group;
        $this-&gt;backend-&gt;update( 'Content\\Type\\Group', $groupArr['id'], $groupArr );
    }

    /**
     * @param mixed $groupId
     * @todo Throw exception if group is not found, also if group contains types
     */
    public function deleteGroup( $groupId )
    {
        $this-&gt;backend-&gt;delete( 'Content\\Type\\Group', $groupId );

        // Remove group id from content types
        $types = $this-&gt;backend-&gt;find( 'Content\\Type', array( 'groupIds' =&gt; $groupId ) );
        foreach ( $types as $type )
        {
            $update = false;
            foreach ( $type-&gt;groupIds as $key =&gt; $contentTypeGroupId )
            {
                if ( $contentTypeGroupId == $groupId )
                {
                    unset( $type-&gt;groupIds[$key] );
                    $update = true;
                }
            }

            if ( $update )
            {
                // @todo If groupIds is empty, content type and content of that type should be deleted?
                $this-&gt;backend-&gt;update(
                    'Content\\Type',
                    $type-&gt;id,
                    array( 'groupIds' =&gt; $type-&gt;groupIds )
                );
            }
        }
    }

    /**
     * @param mixed $groupId
     * @return \eZ\Publish\SPI\Persistence\Content\Type\Group
     */
    public function loadGroup( $groupId )
    {
        return $this-&gt;backend-&gt;load( 'Content\\Type\\Group', $groupId );
    }

    /**
     * @return \eZ\Publish\SPI\Persistence\Content\Type\Group[]
     */
    public function loadAllGroups()
    {
        return $this-&gt;backend-&gt;find( 'Content\\Type\\Group', array() );
    }

    /**
     * @param mixed $groupId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @return \eZ\Publish\SPI\Persistence\Content\Type[]
     */
    public function loadContentTypes( $groupId, $status = Type::STATUS_DEFINED )
    {
        return $this-&gt;backend-&gt;find(
            'Content\\Type',
            array( 'groupIds' =&gt; $groupId, 'status' =&gt; $status ),
            array(
                'fieldDefinitions' =&gt; array(
                    'type' =&gt; 'Content\\Type\\FieldDefinition',
                    'match' =&gt; array( '_typeId' =&gt; 'id', '_status' =&gt; 'status' )
                )
            )
        );
    }

    /**
     * Load a content type by id and status
     *
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @return \eZ\Publish\SPI\Persistence\Content\Type
     * @throws \ezp\Base\Exception\NotFound If type with provided status is not found
     */
    public function load( $contentTypeId, $status = Type::STATUS_DEFINED )
    {
        $type = $this-&gt;backend-&gt;find(
            'Content\\Type',
            array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ),
            array(
                'fieldDefinitions' =&gt; array(
                    'type' =&gt; 'Content\\Type\\FieldDefinition',
                    'match' =&gt; array( '_typeId' =&gt; 'id', '_status' =&gt; 'status' )
                )
            )
        );

        if ( !$type )
            throw new NotFound( 'Content\\Type', &quot;{$contentTypeId}' and status '{$status}&quot; );

        return $type[0];
    }

    /**
     * Load a (defined) content type by identifier
     *
     * @param string $identifier
     * @return \eZ\Publish\SPI\Persistence\Content\Type
     * @throws \ezp\Base\Exception\NotFound If defined type is not found
     */
    public function loadByIdentifier( $identifier )
    {
        $type = $this-&gt;backend-&gt;find(
            'Content\\Type',
            array( 'identifier' =&gt; $identifier, 'status' =&gt; Type::STATUS_DEFINED ),
            array(
                'fieldDefinitions' =&gt; array(
                    'type' =&gt; 'Content\\Type\\FieldDefinition',
                    'match' =&gt; array( '_typeId' =&gt; 'id', '_status' =&gt; 'status' )
                )
            )
        );

        if ( !$type )
            throw new NotFound( 'Content\\Type', &quot;{$identifier}' and status '&quot; . Type::STATUS_DEFINED );

        return $type[0];
    }

    /**
     * @param \eZ\Publish\SPI\Persistence\Content\Type\CreateStruct $contentType
     * @return \eZ\Publish\SPI\Persistence\Content\Type
     */
    public function create( CreateStruct $contentType )
    {
        $contentTypeArr = (array)$contentType;
        unset( $contentTypeArr['fieldDefinitions'] );
        $contentTypeObj = $this-&gt;backend-&gt;create( 'Content\\Type', $contentTypeArr );
        foreach ( $contentType-&gt;fieldDefinitions as $field )
        {
            $contentTypeObj-&gt;fieldDefinitions[] = $this-&gt;backend-&gt;create(
                'Content\\Type\\FieldDefinition',
                array( '_typeId' =&gt; $contentTypeObj-&gt;id, '_status' =&gt; $contentTypeObj-&gt;status ) + (array)$field
            );
        }
        return $contentTypeObj;
    }

    /**
     * @param mixed $typeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @param \eZ\Publish\SPI\Persistence\Content\Type\UpdateStruct $contentType
     */
    public function update( $typeId, $status, UpdateStruct $contentType )
    {
        $contentTypeArr = (array)$contentType;
        $this-&gt;backend-&gt;updateByMatch(
            'Content\\Type',
            array( 'id' =&gt; $typeId, 'status' =&gt; $status ),
            $contentTypeArr
        );
    }

    /**
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     */
    public function delete( $contentTypeId, $status )
    {
        $this-&gt;backend-&gt;deleteByMatch(
            'Content\\Type',
            array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status )
        );
        $this-&gt;backend-&gt;deleteByMatch(
            'Content\\Type\\FieldDefinition',
            array( '_typeId' =&gt; $contentTypeId, '_status' =&gt; $status )
        );
    }

    /**
     * Creates a draft of existing defined content type
     *
     * Updates modified date, sets $modifierId and status to Type::STATUS_DRAFT on the new returned draft.
     *
     * @param mixed $modifierId
     * @param mixed $contentTypeId
     * @return \eZ\Publish\SPI\Persistence\Content\Type
     * @throws \ezp\Base\Exception\NotFound If type with defined status is not found
     */
    public function createDraft( $modifierId, $contentTypeId )
    {
        $contentType = $this-&gt;load( $contentTypeId );
        $contentType-&gt;modified = time();
        $contentType-&gt;modifierId = $modifierId;
        $contentType-&gt;status = Type::STATUS_DRAFT;

        $contentTypeArr = (array)$contentType;
        unset( $contentTypeArr['fieldDefinitions'] );

        $contentTypeObj = $this-&gt;backend-&gt;create( 'Content\\Type', $contentTypeArr, false );
        foreach ( $contentType-&gt;fieldDefinitions as $field )
        {
            $contentTypeObj-&gt;fieldDefinitions[] = $this-&gt;backend-&gt;create(
                'Content\\Type\\FieldDefinition',
                array( '_typeId' =&gt; $contentTypeObj-&gt;id, '_status' =&gt; $contentTypeObj-&gt;status ) + (array)$field
            );
        }
        return $contentTypeObj;
    }

    /**
     * Copy a Type incl fields and group-relations from a given status to a new Type with status {@link Type::STATUS_DRAFT}
     *
     * New Content Type will have $userId as creator / modifier, created / modified should be updated, new remoteId
     * and identifier should be appended with '_' and new remoteId or another unique number.
     *
     * @param mixed $userId
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @return \eZ\Publish\SPI\Persistence\Content\Type
     * @throws \ezp\Base\Exception\NotFound If user or type with provided status is not found
     */
    public function copy( $userId, $contentTypeId, $status )
    {
        $type = $this-&gt;load( $contentTypeId, $status );

        // @todo Validate $userId
        $struct = new CreateStruct();
        foreach ( $struct as $property =&gt; $value )
        {
            $struct-&gt;$property = $type-&gt;$property;
        }
        $struct-&gt;created = $struct-&gt;modified = time();
        $struct-&gt;creatorId = $struct-&gt;modifierId = $userId;
        $struct-&gt;status = Type::STATUS_DRAFT;
        $struct-&gt;identifier .= '_' . ( $struct-&gt;remoteId = md5( uniqid( get_class( $struct ), true ) ) );
        return $this-&gt;create( $struct );// this takes care of resetting _typeId and _status on fields
    }

    /**
     * Unlink a content type group from a content type
     *
     * @param mixed $groupId
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @throws \ezp\Base\Exception\NotFound If group or type with provided status is not found
     * @throws \ezp\Base\Exception\BadRequest If type is not part of group or group is last on type (delete type instead)
     */
    public function unlink( $groupId, $contentTypeId, $status )
    {
        $list = $this-&gt;backend-&gt;find( 'Content\\Type', array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ) );
        if ( !isset( $list[0] ) )
            throw new NotFound( 'Content\\Type', &quot;{$contentTypeId}' and status '{$status}&quot; );

        $type = $list[0];
        if ( !in_array( $groupId, $type-&gt;groupIds ) )
            throw new BadRequest( &quot;group:{$groupId}&quot;, &quot;groupIds on Type:{$contentTypeId}&quot; );

        if ( !isset( $type-&gt;groupIds[1] ) )
            throw new BadRequest(
                'groups',
                &quot;Type: {$contentTypeId}.\nCan not remove last Group: {$groupId}, delete Type instead&quot;
            );

        if ( !$this-&gt;backend-&gt;load( 'Content\\Type\\Group', $groupId ) )
            throw new NotFound( 'Content\\Type\\Group', $groupId );

        $this-&gt;backend-&gt;updateByMatch(
            'Content\\Type',
            array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ),
            array( 'groupIds' =&gt; array_values( array_diff( $type-&gt;groupIds, array( $groupId ) ) ) )
        );
    }

    /**
     * Link a content type group with a content type
     *
     * @param mixed $groupId
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @throws \ezp\Base\Exception\NotFound If group or type with provided status is not found
     * @throws \ezp\Base\Exception\BadRequest If type is already part of group
     */
    public function link( $groupId, $contentTypeId, $status )
    {
        $list = $this-&gt;backend-&gt;find( 'Content\\Type', array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ) );
        if ( !isset( $list[0] ) )
            throw new NotFound( 'Content\\Type', &quot;{$contentTypeId}' and status '{$status}&quot; );

        $type = $list[0];
        if ( in_array( $groupId, $type-&gt;groupIds ) )
            throw new BadRequest( &quot;group:{$groupId}&quot;, &quot;groupIds on Type:{$contentTypeId}&quot; );

        if ( !$this-&gt;backend-&gt;load( 'Content\\Type\\Group', $groupId ) )
            throw new NotFound( 'Content\\Type\\Group', $groupId );

        $this-&gt;backend-&gt;updateByMatch(
            'Content\\Type',
            array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ),
            array( 'groupIds' =&gt; array_merge( $type-&gt;groupIds, array( $groupId ) ) )
        );
    }

    /**
     * Adds a new field definition to an existing Type.
     *
     * This method creates a new version of the Type with the $fieldDefinition
     * added. It does not update existing content objects depending on the
     * field (default) values.
     *
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @param \eZ\Publish\SPI\Persistence\Content\Type\FieldDefinition $fieldDefinition
     * @return \eZ\Publish\SPI\Persistence\Content\Type\FieldDefinition
     * @throws \ezp\Base\Exception\NotFound If type is not found
     * @todo Add FieldDefintion\CreateStruct?
     */
    public function addFieldDefinition( $contentTypeId, $status, FieldDefinition $fieldDefinition )
    {
        $list = $this-&gt;backend-&gt;find( 'Content\\Type', array( 'id' =&gt; $contentTypeId, 'status' =&gt; $status ) );
        if ( !isset( $list[0] ) )
            throw new NotFound( 'Content\\Type', &quot;{$contentTypeId}' and status '{$status}&quot; );

        $fieldDefinitionArr = (array)$fieldDefinition;
        $fieldDefinitionArr['_typeId'] = $contentTypeId;
        $fieldDefinitionArr['_status'] = $status;

        return $this-&gt;backend-&gt;create( 'Content\\Type\\FieldDefinition', $fieldDefinitionArr );
    }

    /**
     * Removes a field definition from an existing Type.
     *
     * This method creates a new version of the Type with the field definition
     * referred to by $fieldDefinitionId removed. It does not update existing
     * content objects depending on the field (default) values.
     *
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @param mixed $fieldDefinitionId
     * @return void
     * @throws \ezp\Base\Exception\NotFound If field is not found
     * @todo Add FieldDefintion\UpdateStruct?
     */
    public function removeFieldDefinition( $contentTypeId, $status, $fieldDefinitionId )
    {
        $this-&gt;backend-&gt;deleteByMatch(
            'Content\\Type\\FieldDefinition',
            array(
                '_typeId' =&gt; $contentTypeId,
                '_status' =&gt; $status,
                'id' =&gt; $fieldDefinitionId,
            )
        );
    }

    /**
     * This method updates the given $fieldDefinition on a Type.
     *
     * This method creates a new version of the Type with the updated
     * $fieldDefinition. It does not update existing content objects depending
     * on the
     * field (default) values.
     *
     * @param mixed $contentTypeId
     * @param int $status One of Type::STATUS_DEFINED|Type::STATUS_DRAFT|Type::STATUS_MODIFIED
     * @param \eZ\Publish\SPI\Persistence\Content\Type\FieldDefinition $fieldDefinition
     * @return void
     * @throws \ezp\Base\Exception\NotFound If field is not found
     */
    public function updateFieldDefinition( $contentTypeId, $status, FieldDefinition $fieldDefinition )
    {
        $fieldDefinitionArr = (array)$fieldDefinition;
        $updated = $this-&gt;backend-&gt;updateByMatch(
            'Content\\Type\\FieldDefinition',
            array(
                '_typeId' =&gt; $contentTypeId,
                '_status' =&gt; $status,
                'id' =&gt; $fieldDefinition-&gt;id,
            ),
            $fieldDefinitionArr
        );
        if ( !$updated )
            throw new NotFound( 'Content\\Type\\FieldDefinition', $fieldDefinition-&gt;id );
    }

    /**
     * Update content objects
     *
     * Updates content objects, depending on the changed field definitions.
     *
     * A content type has a state which tells if its content objects yet have
     * been adapted.
     *
     * Flags the content type as updated.
     *
     * @param mixed $contentTypeId
     * @return void
     * @throws \ezp\Base\Exception\NotFound If type with $contentTypeId and Type::STATUS_DRAFT is not found
     */
    public function publish( $contentTypeId )
    {
        $draftType = $this-&gt;load( $contentTypeId, Type::STATUS_DRAFT );
        try
        {
            $publishedType = $this-&gt;load( $contentTypeId );
        }
        catch ( NotFound $e )
        {
            // No published version of type, jump to last section where draft is promoted to defined
            GOTO updateType;
        }

        // @todo update content based on new type data change (field/scheme changes from $publishedType to $draftType)
        $this-&gt;backend-&gt;deleteByMatch(
            'Content\\Type',
            array( 'id' =&gt; $contentTypeId, 'status' =&gt; Type::STATUS_DEFINED )
        );
        $this-&gt;backend-&gt;deleteByMatch(
            'Content\\Type\\FieldDefinition',
            array( '_typeId' =&gt; $contentTypeId, '_status' =&gt; Type::STATUS_DEFINED )
        );

        updateType:
        {
            $this-&gt;backend-&gt;updateByMatch(
                'Content\\Type',
                array( 'id' =&gt; $contentTypeId, 'status' =&gt; Type::STATUS_DRAFT ),
                array( 'status' =&gt; Type::STATUS_DEFINED )
            );
            $this-&gt;backend-&gt;updateByMatch(
                'Content\\Type\\FieldDefinition',
                array(
                    '_typeId' =&gt; $contentTypeId,
                    '_status' =&gt; Type::STATUS_DRAFT,
                ),
                array( '_status' =&gt; Type::STATUS_DEFINED )
            );
        }
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>