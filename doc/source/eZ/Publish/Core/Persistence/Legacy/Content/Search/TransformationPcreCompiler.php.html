<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the TransformationPcreCompiler class
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 *
 */

namespace eZ\Publish\Core\Persistence\Legacy\Content\Search;
use eZ\Publish\SPI\Persistence\Fields\Storage;

/**
 * Compiles the AST of parsed transformation rules into a set of PCRE replace
 * regular expressions.
 */
class TransformationPcreCompiler
{
    /**
     * Class for converting UTF-8 characters
     *
     * @var Utf8Converter
     */
    protected $converter;

    /**
     * Construct from UTF8Converter
     *
     * @param Utf8Converter $converter
     * @return void
     */
    public function __construct( Utf8Converter $converter )
    {
        $this-&gt;converter = $converter;
    }

    /**
     * Compile AST into a set of regular expressions
     *
     * The returned array contains a set of regular expressions and their
     * replacement callbacks. The regular expressions can then be applied to
     * strings to executed the transformations.
     *
     * @param array $ast
     * @return array
     */
    public function compile( array $ast )
    {
        $transformations = array();

        foreach ( $ast as $section =&gt; $rules )
        {
            foreach ( $rules as $rule )
            {
                $transformations[$section][] = $this-&gt;compileRule( $rule );
            }
        }

        return $transformations;
    }

    /**
     * Compiles a single rule
     *
     * @param array $rule
     * @return array
     */
    protected function compileRule( array $rule )
    {
        switch ( $rule['type'] )
        {
            case TransformationParser::T_MAP:
                return $this-&gt;compileMap( $rule );

            case TransformationParser::T_REPLACE:
                return $this-&gt;compileReplace( $rule );

            case TransformationParser::T_TRANSPOSE:
                return $this-&gt;compileTranspose( $rule );

            case TransformationParser::T_TRANSPOSE_MODULO:
                return $this-&gt;compileTransposeModulo( $rule );

            default:
                throw new \RuntimeException( &quot;Unknown rule type: &quot; . $rule['type'] );
        }
    }

    /**
     * Compile map rule
     *
     * @param array $rule
     * @return array
     */
    protected function compileMap( array $rule )
    {
        return array(
            'regexp' =&gt; '(' . preg_quote( $this-&gt;compileCharacter( $rule['data']['src'] ) ) . ')us',
            'callback' =&gt; $this-&gt;compileTargetCharacter( $rule['data']['dest'] ),
        );
    }

    /**
     * Compile replace rule
     *
     * @param array $rule
     * @return array
     */
    protected function compileReplace( array $rule )
    {
        return array(
            'regexp' =&gt; '([' .
                preg_quote( $this-&gt;compileCharacter( $rule['data']['srcStart'] ) ) . '-' .
                preg_quote( $this-&gt;compileCharacter( $rule['data']['srcEnd'] ) ) .
                '])us',
            'callback' =&gt; $this-&gt;compileTargetCharacter( $rule['data']['dest'] ),
        );
    }

    /**
     * Compile transpose rule
     *
     * @param array $rule
     * @return array
     */
    protected function compileTranspose( array $rule )
    {
        return array(
            'regexp' =&gt; '([' .
                preg_quote( $this-&gt;compileCharacter( $rule['data']['srcStart'] ) ) . '-' .
                preg_quote( $this-&gt;compileCharacter( $rule['data']['srcEnd'] ) ) .
                '])us',
            'callback' =&gt; $this-&gt;getTransposeClosure( $rule['data']['op'], $rule['data']['dest'] ),
        );
    }

    /**
     * Compile transpose modulo rule
     *
     * @param array $rule
     * @return array
     */
    protected function compileTransposeModulo( array $rule )
    {
        return array(
            'regexp' =&gt; '([' .
                preg_quote(
                    $this-&gt;getModuloCharRange(
                        $this-&gt;compileCharacter( $rule['data']['srcStart'] ),
                        $this-&gt;compileCharacter( $rule['data']['srcEnd'] ),
                        $rule['data']['modulo']
                    )
                ) .
                '])us',
            'callback' =&gt; $this-&gt;getTransposeClosure( $rule['data']['op'], $rule['data']['dest'] ),
        );
    }

    /**
     * Get string with all characters defined by parameters
     *
     * Returns a string containing all UTF-8 characters starting with the
     * specified $start character up to the $end character with the step size
     * defined in $modulo.
     *
     * @param string $start
     * @param string $end
     * @param string $modulo
     * @return string
     */
    protected function getModuloCharRange( $start, $end, $modulo )
    {
        $start = $this-&gt;converter-&gt;toUnicodeCodepoint( $start );
        $end = $this-&gt;converter-&gt;toUnicodeCodepoint( $end );
        $modulo = hexdec( $modulo );

        $chars = '';
        for ( $start; $start &lt;= $end; $start += $modulo )
        {
            $chars .= $this-&gt;converter-&gt;toUTF8Character( $start );
        }

        return $chars;
    }

    /**
     * Return a closure which modifies the provided character by the given
     * value
     *
     * @param string $operator
     * @param string $value
     * @return callback
     */
    protected function getTransposeClosure( $operator, $value )
    {
        $value = hexdec( $value ) * ( $operator === '-' ? -1 : 1 );
        $converter = $this-&gt;converter;
        return function ( $matches ) use ( $value, $converter )
        {
            return $converter-&gt;toUTF8Character(
                $converter-&gt;toUnicodeCodepoint( $matches[0] ) + $value
            );
        };
    }

    /**
     * Compile target into a closure, which can be used by
     * preg_replace_callback
     *
     * @param string $char
     * @return callback
     */
    protected function compileTargetCharacter( $char )
    {
        switch ( true )
        {
            case ( $char === 'remove' ):
                return function( $matches )
                {
                    return '';
                };

            case ( $char === 'keep' ):
                return function( $matches )
                {
                    return $matches[0];
                };

            case preg_match( '(&quot;(?:[^\\\\&quot;]+|\\\\\\\\|\\\\\'|\\\\&quot;)*?&quot;)', $char );
                $string = str_replace(
                    array( '\\\\', '\\&quot;', &quot;\\'&quot; ),
                    array( '\\', '&quot;', &quot;'&quot; ),
                    substr( $char, 1, -1 )
                );

                return function( $matches ) use ( $string )
                {
                    return $string;
                };

            default:
                $char = $this-&gt;compileCharacter( $char );
                return function( $matches ) use ( $char )
                {
                    return $char;
                };
        }
    }

    /**
     * Compile a single source character definition into a plain UTF-8 character
     *
     * Handles the two formats from the possible character definitions:
     *  - U+xxxx : Unicode value in hexadecimal
     *  - xx: Ascii value in hexadecimal
     *
     * @param string $char
     * @return string
     */
    protected function compileCharacter( $char )
    {
        switch ( true )
        {
            case preg_match( '(^U\\+[0-9a-fA-F]{4}$)', $char ):
                return $this-&gt;converter-&gt;toUTF8Character( hexdec( substr( $char, 2 ) ) );

            case preg_match( '(^[0-9a-fA-F]{2}$)', $char ):
                return chr( hexdec( $char ) );

            default:
                throw new \RuntimeException( &quot;Invalid character definition: $char&quot; );
        }
    }
}

</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>