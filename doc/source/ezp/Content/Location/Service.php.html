<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the ezp\Content\Location\Service class.
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 */

namespace ezp\Content\Location;
use ezp\Base\Exception,
    ezp\Base\Exception\Forbidden,
    ezp\Base\Exception\NotFound,
    ezp\Base\Exception\Logic,
    ezp\Base\Service as BaseService,
    ezp\Base\Collection\Lazy,
    ezp\Base\Collection\LazyType,
    ezp\Content\Location,
    ezp\Content\Location\Concrete as ConcreteLocation,
    ezp\Content\Location\Proxy as ProxyLocation,
    ezp\Content\Location\Exception\NotFound as LocationNotFound,
    ezp\Content\Section,
    ezp\Content\Proxy as ProxyContent,
    ezp\Content\Query,
    ezp\Content\Query\Builder,
    eZ\Publish\SPI\Persistence\Content\Location as LocationValue,
    eZ\Publish\SPI\Persistence\Content\Location\CreateStruct,
    eZ\Publish\SPI\Persistence\Content\Location\UpdateStruct;

/**
 * Location service, used for complex subtree operations
 */
class Service extends BaseService
{

    /**
     * Copies the subtree starting from $subtree as a new subtree of $targetLocation
     *
     * @param \ezp\Content\Location $subtree
     * @param \ezp\Content\Location $targetLocation
     *
     * @return \ezp\Content\Location The newly created subtree
     * @throws \ezp\Content\Location\Exception\NotFound
     * @todo Permission checking, is it possible w/o loading all content in the subtree?
     */
    public function copySubtree( Location $subtree, Location $targetLocation )
    {
        try
        {
            return $this-&gt;buildDomainObject(
                $this-&gt;handler-&gt;locationHandler()-&gt;copySubtree(
                    $subtree-&gt;id,
                    $targetLocation-&gt;id
                )
            );
        }
        catch ( NotFound $e )
        {
            throw new LocationNotFound( $e-&gt;identifier, $e );
        }
    }

    /**
     * Loads a location object from its $locationId
     * @param integer $locationId
     * @return \ezp\Content\Location
     * @throws \ezp\Content\Location\Exception\NotFound if no location is available with $locationId
     */
    public function load( $locationId )
    {
        try
        {
            $locationVO = $this-&gt;handler-&gt;locationHandler()-&gt;load( $locationId );
        }
        catch ( NotFound $e )
        {
            throw new LocationNotFound( $locationId, $e );
        }

        return $this-&gt;buildDomainObject( $locationVO );
    }

    /**
     * Load children of a location object sorted by sortField and sortOrder
     *
     * @access private Used internally by $location-&gt;children
     * @param \ezp\Content\Location $location
     * @return \ezp\Content\Location[]
     * @todo Should take parentId as input to avoid cyclic references, the extra load will eventually be handled with
     *       identity map / object cache
     */
    public function children( Location $location )
    {
        // reuses contentService-&gt;find() for permissions and other reasons
        if ( $location-&gt;sortOrder === Location::SORT_ORDER_ASC )
            $order = Query::SORT_ASC;
        else
            $order = Query::SORT_DESC;

        $qb = new Builder();
        $qb-&gt;addCriteria( $qb-&gt;parentLocationId-&gt;eq( $location-&gt;id ) );

        switch ( $location-&gt;sortField )
        {
            case Location::SORT_FIELD_SECTION:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;sectionName( $order ) );
                break;
            case Location::SORT_FIELD_PRIORITY:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;locationPriority( $order ) );
                break;
            case Location::SORT_FIELD_PATH:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;locationPathString( $order ) );
                break;
            case Location::SORT_FIELD_DEPTH:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;locationDepth( $order ) );
                break;
            case Location::SORT_FIELD_MODIFIED:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;dateModified( $order ) );
                break;
            case Location::SORT_FIELD_NAME:
                $qb-&gt;addSortClause( $qb-&gt;sort-&gt;contentName( $order ) );
                break;
            default:
                throw new Logic(
                    &quot;\$location-&gt;sortField:'{$location-&gt;sortField}'&quot;,
                    &quot;does mot currently have a corresponding SortClause&quot;
                );
        }

        $children = array();
        $result = $this-&gt;repository-&gt;getContentService()-&gt;find( $qb-&gt;getQuery() );
        foreach ( $result as $childContent )
        {
            foreach ( $childContent-&gt;getLocations() as $child )
            {
                if ( $child-&gt;parentId == $location-&gt;id )
                {
                    $children[] = $child;
                    continue 2;
                }
            }
            throw new Logic(
                __METHOD__,
                &quot;One of the returned content objects did not contain locations that where children of \$location&quot;
            );
        }
        return $children;
    }

    /**
     * Creates the new $location in the content repository
     *
     * @param \ezp\Content\Location $location
     * @return \ezp\Content\Location the newly created Location
     * @throws \ezp\Base\Exception\Logic If a validation problem has been found for $content
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to create provided object
     */
    public function create( Location $location )
    {
        if ( $location-&gt;parentId == 0 )
        {
            throw new Logic( 'Location', 'Parent location is not defined' );
        }

        if ( !$this-&gt;repository-&gt;canUser( 'create', $location-&gt;getContent(), $location-&gt;getParent() ) )
            throw new Forbidden( 'Content', 'create' );

        // @todo Use fillStruct to not potentially pass empty properties to handler
        $struct = new CreateStruct();
        foreach ( $location-&gt;properties() as $name )
        {
            if ( property_exists( $struct, $name ) )
            {
                $struct-&gt;$name = $location-&gt;$name;
            }
        }

        $parent = $location-&gt;getParent();
        $struct-&gt;invisible = ( $parent-&gt;invisible == true ) || ( $parent-&gt;hidden == true );
        $struct-&gt;contentId = $location-&gt;contentId;
        $struct-&gt;priority = (int)$location-&gt;priority;

        $vo = $this-&gt;handler-&gt;locationHandler()-&gt;create( $struct );
        $location-&gt;setState( array( 'properties' =&gt; $vo ) );

        // repo/storage stuff
        return $location;
    }

    /**
     * Updates $location in the content repository
     *
     * @param \ezp\Content\Location $location
     * @return \ezp\Content\Location the updated Location
     * @throws \ezp\Base\Exception\Logic If a validation problem has been found for $location
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to edit provided object
     */
    public function update( Location $location )
    {
        if ( !$this-&gt;repository-&gt;canUser( 'edit', $location-&gt;getContent() ) )
            throw new Forbidden( 'Content', 'edit' );

        // @todo Use fillStruct to not potentially pass empty properties to handler
        $struct = new UpdateStruct;
        foreach ( $location-&gt;properties() as $name )
        {
            if ( property_exists( $struct, $name ) )
            {
                $struct-&gt;$name = $location-&gt;$name;
            }
        }

        if ( !$this-&gt;handler-&gt;locationHandler()-&gt;update( $struct, $location-&gt;id ) )
        {
            throw new Logic( &quot;Location #{$location-&gt;id}&quot;, 'Could not be updated' );
        }

        return $location;
    }

    /**
     * Swaps the contents hold by the $location1 and $location2
     *
     * @param \ezp\Content\Location $location1
     * @param \ezp\Content\Location $location2
     * @return void
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to create provided objects
     */
    public function swap( Location $location1, Location $location2 )
    {
        if ( !$this-&gt;repository-&gt;canUser( 'create', $location1-&gt;getContent(), $location2-&gt;getParent() ) )
            throw new Forbidden( 'Content', 'create' );
        if ( !$this-&gt;repository-&gt;canUser( 'create', $location2-&gt;getContent(), $location1-&gt;getParent() ) )
            throw new Forbidden( 'Content', 'create' );

        $location1Id = $location1-&gt;id;
        $location2Id = $location2-&gt;id;

        $this-&gt;handler-&gt;locationHandler()-&gt;swap( $location1Id, $location2Id );

        // @todo shouldn't content objects be swapped on location objects here?

        // Update Domain objects references
        $this-&gt;refreshDomainObject( $location1 );
        $this-&gt;refreshDomainObject( $location2 );
    }

    /**
     * Hides the $location and marks invisible all descendants of $location.
     *
     * @param \ezp\Content\Location $location
     * @return \ezp\Content\Location $location, with updated hidden value
     * @todo Make children visibility update more dynamic with some kind of LazyLoadedCollection
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to hide provided object
     */
    public function hide( Location $location )
    {
        if ( !$this-&gt;repository-&gt;canUser( 'hide', $location-&gt;getContent(), $location ) )
            throw new Forbidden( 'Content', 'hide' );

        $this-&gt;handler-&gt;locationHandler()-&gt;hide( $location-&gt;id );

        // Get VO &amp; update hidden property
        $location-&gt;getState( 'properties' )-&gt;hidden = true;

        $children = $location-&gt;getChildren();
        if ( $children instanceof Lazy &amp;&amp; !$children-&gt;isLoaded() )
            return $location;

        foreach ( $children as $child )
        {
            $child-&gt;getState( 'properties' )-&gt;invisible = true;
        }

        return $location;
    }

    /**
     * Unhides the $location and marks visible all descendants of $locations
     * until a hidden location is found.
     *
     * @param \ezp\Content\Location $location
     * @return \ezp\Content\Location $location, with updated hidden value
     * @todo Make children visibility update more dynamic with some kind of LazyLoadedCollection
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to (un)hide provided object
     */
    public function unhide( Location $location )
    {
        if ( !$this-&gt;repository-&gt;canUser( 'hide', $location-&gt;getContent(), $location ) )
            throw new Forbidden( 'Content', 'unhide' );

        $this-&gt;handler-&gt;locationHandler()-&gt;unHide( $location-&gt;id );

        // Get VO &amp; update hidden property
        $location-&gt;getState( 'properties' )-&gt;hidden = false;

        $children = $location-&gt;getChildren();
        if ( $children instanceof Lazy &amp;&amp; !$children-&gt;isLoaded() )
            return $location;

        foreach ( $children as $child )
        {
            $child-&gt;getState( 'properties' )-&gt;invisible = false;
        }

        return $location;
    }

    /**
     * Moves $location under $newParent and updates all descendants of
     * $location accordingly.
     *
     * @param \ezp\Content\Location $location
     * @param \ezp\Content\Location $newParent
     * @return void
     * @todo Figure out a way to do permissions w/o loading whole tree
     */
    public function move( Location $location, Location $newParent )
    {
        $this-&gt;handler-&gt;locationHandler()-&gt;move( $location-&gt;id, $newParent-&gt;id );
        $this-&gt;refreshDomainObject( $location );
    }

    /**
     * Deletes the $locations and all descendants of $location.
     *
     * @param \ezp\Content\Location $location
     * @return void
     * @throws \ezp\Base\Exception\NotFound if no location is available with $locationId
     * @throws \ezp\Base\Exception\Forbidden If user does not have access to remove provided object
     * @todo Do we need to check permissions for delete on children? Or should we document that
     * giving access to deleting implicit gives a user access to remove all childes no matter what?
     */
    public function delete( Location $location )
    {
        if ( !$this-&gt;repository-&gt;canUser( 'remove', $location-&gt;getContent(), $location ) )
            throw new Forbidden( 'Content', 'remove' );

        $this-&gt;handler-&gt;locationHandler()-&gt;removeSubtree( $location-&gt;id );
        $this-&gt;refreshDomainObject( $location, $location-&gt;getState( 'properties' ) );
    }

    /**
     * Assigns $section to the contents held by $startingPoint location and
     * all contents held by descendants location of $startingPoint
     *
     * @param \ezp\Content\Location $startingPoint
     * @param \ezp\Content\Section $section
     * @return void
     * @todo Figure out how to do permission checks w/o loading whole tree
     */
    public function assignSection( Location $startingPoint, Section $section )
    {
        $this-&gt;handler-&gt;locationHandler()-&gt;setSectionForSubtree( $startingPoint-&gt;id, $section-&gt;id );
        $this-&gt;refreshDomainObject( $startingPoint );
    }

    /**
     * Builds Location domain object from $vo ValueObject returned by Persistence API
     * @param \eZ\Publish\SPI\Persistence\Location $vo Location value object (extending \eZ\Publish\SPI\Persistence\ValueObject)
     *                                      returned by persistence
     * @return \ezp\Content\Location
     * @throws \ezp\Base\Exception\InvalidArgumentType
     */
    protected function buildDomainObject( LocationValue $vo )
    {
        $location = new ConcreteLocation( new ProxyContent( $vo-&gt;contentId, $this-&gt;repository-&gt;getContentService() ) );

        return $this-&gt;refreshDomainObject( $location, $vo );
    }

    /**
     * Refreshes provided $location. Useful if backend data has changed
     *
     * @param \ezp\Content\Location $location Location to refresh
     * @param \ezp\Persistence\Location $vo Location value object. If provided, $location will be updated with $vo's data
     * @return \ezp\Content\Location
     * @throws \ezp\Base\Exception\InvalidArgumentType
     */
    protected function refreshDomainObject( Location $location, LocationValue $vo = null )
    {
        if ( $vo === null )
        {
            $vo = $this-&gt;handler-&gt;locationHandler()-&gt;load( $location-&gt;id );
        }

        $newState = array(
            'properties' =&gt; $vo,
            'parent' =&gt; new ProxyLocation( $vo-&gt;parentId, $this ),
            'children' =&gt; new LazyType(
                'ezp\\Content\\Location',
                $this,
                // api uses location to be able to use sort info
                $location,
                'children'
            )
        );
        // Check if associated content also needs to be refreshed
        if ( $vo-&gt;contentId != $location-&gt;contentId )
        {
            $newState['content'] = new ProxyContent( $vo-&gt;contentId, $this-&gt;repository-&gt;getContentService() );
        }
        $location-&gt;setState( $newState );

        return $location;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>