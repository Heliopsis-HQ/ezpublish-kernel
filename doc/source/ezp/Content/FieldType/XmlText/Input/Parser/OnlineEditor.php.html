<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the ezp\Content\FieldType\XmlText\Input\Parser\OnlineEditor class.
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 */

namespace ezp\Content\FieldType\XmlText\Input\Parser;

use ezp\Content\FieldType\XmlText\Input\Parser as InputParser,
    ezp\Content\FieldType\XmlText\Input\Parser\Base as BaseParser,
    ezp\Base\Configuration,
    DOMElement;

/**
 * OnlineEditor XmlText input parser.
 *
 * Parses X(HT)ML produced by the OnlineEditor.
 */
class OnlineEditor extends BaseParser implements InputParser
{
    /**
     * Used to strip out ezoe, tinymce &amp; browser specific classes
     */
    const HTML_CLASS_REGEX = &quot;/(webkit-[\w\-]+|Apple-[\w\-]+|mceItem\w+|ezoeItem\w+|mceVisualAid)/i&quot;;

    /**
     * Maps input tags (html) to a output tag or a hander to
     * decide what kind of ezxml tag to use.
     *
     * @var array $InputTags
     */
    protected $InputTags = array(
        'section' =&gt; array( 'name' =&gt; 'section' ),
        'b'       =&gt; array( 'name' =&gt; 'strong' ),
        'bold'    =&gt; array( 'name' =&gt; 'strong' ),
        'strong'  =&gt; array( 'name' =&gt; 'strong' ),
        'i'       =&gt; array( 'name' =&gt; 'emphasize' ),
        'em'      =&gt; array( 'name' =&gt; 'emphasize' ),
        'pre'     =&gt; array( 'name' =&gt; 'literal' ),
        'div'     =&gt; array( 'nameHandler' =&gt; 'tagNameDivnImg' ),
        'u'       =&gt; array( 'nameHandler' =&gt; 'tagNameCustomHelper' ),
        'sub'       =&gt; array( 'nameHandler' =&gt; 'tagNameCustomHelper' ),
        'sup'       =&gt; array( 'nameHandler' =&gt; 'tagNameCustomHelper' ),
        'img'     =&gt; array( 'nameHandler' =&gt; 'tagNameDivnImg',
                            'noChildren' =&gt; true ),
        'h1'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'h2'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'h3'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'h4'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'h5'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'h6'      =&gt; array( 'nameHandler' =&gt; 'tagNameHeader' ),
        'p'       =&gt; array( 'name' =&gt; 'paragraph' ),
        'br'      =&gt; array( 'name' =&gt; 'br',
                            'noChildren' =&gt; true ),
        'span'    =&gt; array( 'nameHandler' =&gt; 'tagNameSpan' ),
        'table'   =&gt; array( 'nameHandler' =&gt; 'tagNameTable' ),
        'td'      =&gt; array( 'name' =&gt; 'td' ),
        'tr'      =&gt; array( 'name' =&gt; 'tr' ),
        'th'      =&gt; array( 'name' =&gt; 'th' ),
        'ol'      =&gt; array( 'name' =&gt; 'ol' ),
        'ul'      =&gt; array( 'name' =&gt; 'ul' ),
        'li'      =&gt; array( 'name' =&gt; 'li' ),
        'a'       =&gt; array( 'nameHandler' =&gt; 'tagNameLink' ),
        'link'    =&gt; array( 'nameHandler' =&gt; 'tagNameLink' ),
       // Stubs for not supported tags.
        'tbody'   =&gt; array( 'name' =&gt; '' ),
        'thead'   =&gt; array( 'name' =&gt; '' ),
        'tfoot'   =&gt; array( 'name' =&gt; '' )
    );

    /**
     * Maps output tags (ezxml) to varius handlers at different stages
     * decide what kind of ezxml tag to use.
     *
     * @var array $OutputTags
     */
    protected $OutputTags = array(
        'section'   =&gt; array(),

        'embed'     =&gt; array( 'initHandler'    =&gt; 'transformStyles',
                              'structHandler'  =&gt; 'appendLineParagraph',
                              'publishHandler' =&gt; 'publishHandlerEmbed',
                              'attributes'     =&gt; array( 'alt' =&gt; 'size',
                                                         'html_id' =&gt; 'xhtml:id' ) ),

        'embed-inline' =&gt; array( 'initHandler'    =&gt; 'transformStyles',
                                 'structHandler'  =&gt; 'appendLineParagraph',
                                 'publishHandler' =&gt; 'publishHandlerEmbed',
                                 'attributes'     =&gt; array( 'alt' =&gt; 'size',
                                                            'html_id' =&gt; 'xhtml:id' ) ),

        'table'     =&gt; array( 'initHandler'   =&gt; 'transformStyles',
                              'structHandler' =&gt; 'appendParagraph',
                              'attributes'    =&gt; array( 'border' =&gt; false,
                                                        'ezborder' =&gt; 'border' ) ),

        'tr'        =&gt; array(),

        'td'        =&gt; array( 'initHandler' =&gt; 'transformStyles',
                              'attributes'  =&gt; array( 'width' =&gt; 'xhtml:width',
                                                      'colspan' =&gt; 'xhtml:colspan',
                                                      'rowspan' =&gt; 'xhtml:rowspan' ) ),

        'th'        =&gt; array( 'initHandler' =&gt; 'transformStyles',
                              'attributes'  =&gt; array( 'width' =&gt; 'xhtml:width',
                                                      'colspan' =&gt; 'xhtml:colspan',
                                                      'rowspan' =&gt; 'xhtml:rowspan' ) ),

        'ol'        =&gt; array( 'structHandler' =&gt; 'structHandlerLists' ),

        'ul'        =&gt; array( 'structHandler' =&gt; 'structHandlerLists' ),

        'li'        =&gt; array( 'autoCloseOn' =&gt; array( 'li' ) ),

        'header'    =&gt; array( 'initHandler'   =&gt; 'initHandlerHeader',
                              'autoCloseOn'   =&gt; array( 'paragraph' ),
                              'structHandler' =&gt; 'structHandlerHeader' ),

        'paragraph' =&gt; array( 'parsingHandler' =&gt; 'parsingHandlerParagraph',
                              'autoCloseOn'    =&gt; array( 'paragraph' ),
                              'initHandler'    =&gt; 'transformStyles',
                              'structHandler'  =&gt; 'structHandlerParagraph' ),

        'line'      =&gt; array(),

        'br'        =&gt; array( 'parsingHandler' =&gt; 'breakInlineFlow',
                              'structHandler'  =&gt; 'structHandlerBr',
                              'attributes'     =&gt; false ),

        'literal'   =&gt; array( 'parsingHandler' =&gt; 'parsingHandlerLiteral',
                              'structHandler'  =&gt; 'appendParagraph',
                              'attributes'     =&gt; array( 'class' =&gt; 'class' ) ),

        'strong'    =&gt; array( 'structHandler' =&gt; 'appendLineParagraph' ),

        'emphasize' =&gt; array( 'structHandler' =&gt; 'appendLineParagraph' ),

        'link'      =&gt; array( 'structHandler'  =&gt; 'appendLineParagraph',
                              'publishHandler' =&gt; 'publishHandlerLink',
                              'attributes'     =&gt; array( 'title' =&gt; 'xhtml:title',
                                                         'id' =&gt; 'xhtml:id' ) ),

        'anchor'    =&gt; array( 'structHandler' =&gt; 'appendLineParagraph' ),

        'custom'    =&gt; array( 'initHandler'   =&gt; 'initHandlerCustom',
                              'structHandler' =&gt; 'structHandlerCustom' ),

        '#text'     =&gt; array( 'structHandler' =&gt; 'structHandlerText' )
    );

    /**
     * Lists of external ids found during parsing
     * @var integer[]
     */
    protected $embeddedObjectIDArray = array();
    protected $deletedEmbeddedNodeIDArray = array();
    protected $deletedEmbeddedObjectIDArray = array();
    protected $thrashedEmbeddedObjectIDArray = array();

    protected $anchorAsAttribute = false;

    /**
     * @var array
     */
    protected static $customTagList = null;

    /**
     * Input handler
     * @var \ezp\Content\FieldType\XmlText\Input\Handler
     */
    protected $handler;

    /**
     * Constructor
     * For more info see {@link eZXMLInputParser::eZXMLInputParser()}
     *
     * @param int $validateErrorLevel
     * @param int $detectErrorLevel
     * @param bool $parseLineBreaks flag if line breaks should be given meaning or not
     * @param bool $removeDefaultAttrs signal if attributes of default value should not be saved.
     */
    public function __construct()
    {
        parent::__construct();

        $configuration = Configuration::getInstance( 'content' );
        if ( $configuration-&gt;has( 'header', 'AnchorAsAttribute' ) )
            $this-&gt;anchorAsAttribute = $configuration-&gt;get( 'header', 'AnchorAsAttribute' ) !== 'disabled';
    }

    /**
     * Process html text and transform it to xml.
     *
     * @param string $text
     * @param bool $createRootNode
     * @return false|DOMDocument
     */
    public function process( $text, $createRootNode = true )
    {
        $text = preg_replace( '#&lt;!--.*?--&gt;#s', '', $text ); // remove HTML comments
        $text = str_replace( array( '&amp;nbsp;', '&amp;#160;', '&amp;#xa0;' ), &quot;\xC2\xA0&quot;, $text );
        return parent::process( $text, $createRootNode );
    }

    /**
     * tagNameSpan (tag mapping handler)
     * Handles span tag and maps it to embed|custom|strong|emphasize|custom.underline
     * Reuses {@link eZOEInputParser::tagNameDivnImg()} for embed and custom tag mapping.
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameSpan( $tagName, &amp;$attributes )
    {
        // embed / custom tag detection code in tagNameDivnImg
        $name = $this-&gt;tagNameDivnImg( $tagName, $attributes );

        if ( $name === '' &amp;&amp; isset( $attributes['style'] ) )
        {
            if ( strpos( $attributes['style'], 'font-weight: bold' ) !== false )
            {
                $name = 'strong';
                unset( $attributes['style'] );
            }
            elseif ( strpos( $attributes['style'], 'font-style: italic' ) !== false )
            {
                $name = 'emphasize';
                unset( $attributes['style'] );
            }
            elseif ( strpos( $attributes['style'], 'text-decoration: underline' ) !== false
                &amp;&amp; self::customTagIsEnabled( 'underline' ) )
            {
                $name = 'custom';
                unset( $attributes['style'] );
                $attributes['name'] = 'underline';
                $attributes['children_required'] = 'true';
            }
        }
        return $name;
    }

    /**
     * tagNameHeader (tag mapping handler)
     * Handles H[1-6] tags and maps them to header tag
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameHeader( $tagName, &amp;$attributes )
    {
        $attributes['level'] = $tagName[1];
        return 'header';
    }

    /**
     * tagNameTable (tag mapping handler)
     * Handles table tag and cleanups some attributes for it
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameTable( $tagName, &amp;$attributes )
    {
        $name = 'table';
        if ( isset( $attributes['border'] ) &amp;&amp; !isset( $attributes['ezborder'] ) )
        {
            $attributes['ezborder'] = $attributes['border'];
        }
        if ( isset( $attributes['class'] ) )
            $attributes['class'] = self::tagClassNamesCleanup( $attributes['class'] );
        return $name;
    }

    /**
     * tagNameDivnImg (tag mapping handler)
     * Handles div|img tags and maps them to embed|embed-inline|custom tag
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameDivnImg( $tagName, &amp;$attributes )
    {
        $name = '';
        if ( isset( $attributes['id'] ) )
        {
            if ( strpos( $attributes['id'], 'eZObject_' ) !== false
                || strpos( $attributes['id'], 'eZNode_' ) !== false )
            {
                // decide if inline or block embed tag
                if ( isset( $attributes['inline'] ) &amp;&amp; $attributes['inline'] === 'true' )
                    $name = 'embed-inline';
                else
                    $name = 'embed';

                unset( $attributes['inline'] );// unset internal stuff to make sure custom attr with same name works

                if ( isset( $attributes['class'] ) )
                {
                    $attributes['class'] = self::tagClassNamesCleanup( $attributes['class'] );
                }
            }
        }

        if ( $name === '' &amp;&amp; isset( $attributes['type'] ) &amp;&amp; $attributes['type'] === 'custom' )
        {
            $name = 'custom';
            unset( $attributes['type'] );// unset internal stuff to make sure custom attr with same name works
            if ( $tagName === 'div' )
                $attributes['children_required'] = 'true';
            $attributes['name'] = self::tagClassNamesCleanup( $attributes['class'] );
            unset( $attributes['class'] );// unset internal stuff to make sure custom attr with same name works
        }

        return $name;
    }

    /**
     * tagNameLink (tag mapping handler)
     * Handles a|link tags and maps them to link|anchor tag
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameLink( $tagName, &amp;$attributes )
    {
        $name = '';
        if ( $tagName === 'link'
            &amp;&amp; isset( $attributes['href'] )
            &amp;&amp; isset( $attributes['rel'] )
            &amp;&amp; ( $attributes['rel'] === 'File-List'
            || $attributes['rel'] === 'themeData'
            || $attributes['rel'] === 'colorSchemeMapping' )
            &amp;&amp; ( strpos( $attributes['href'], '.xml' ) !== false
            || strpos( $attributes['href'], '.thmx' ) !== false) )
        {
            // empty check to not store buggy links created
            // by pasting content from ms word 2007
        }
        else if ( isset( $attributes['href'] ) )
        {
            // normal link tag
            $name = 'link';
            if ( isset( $attributes['name'] ) &amp;&amp; !isset( $attributes['anchor_name'] ) )
            {
                $attributes['anchor_name'] = $attributes['name'];
                unset( $attributes['name'] );// unset internal stuff to make sure custom attr with same name works
            }
        }
        else if ( isset( $attributes['name'] ) )
        {
            // anchor in regular sense
            $name = 'anchor';
        }
        else if ( isset( $attributes['class'] ) &amp;&amp; $attributes['class'] === 'mceItemAnchor' )
        {
            // anchor in TinyMCE sense (was valid up until TinyMCE 3.2)
            $name = 'anchor';
            // ie bug with name attribute, workaround using id instead
            if ( isset( $attributes['id'] ) ) $attributes['name'] = $attributes['id'];
            unset( $attributes['class'] );// unset internal stuff to make sure custom attr with same name works
            unset( $attributes['id'] );
        }

        return $name;
    }

    /**
     * tagNameCustomHelper (tag mapping handler)
     * Handles u|sub|sup tags and maps them to custom tag if they are enabled
     *
     * @param string $tagName name of input (xhtml) tag
     * @param array $attributes byref value of tag attributes
     * @return string name of ezxml tag or blank (then tag is removed, but not it's content)
     */
    protected function tagNameCustomHelper( $tagName, &amp;$attributes )
    {
        $name = '';
        if ( $tagName === 'u' &amp;&amp; self::customTagIsEnabled('underline') )
        {
            $name = 'custom';
            $attributes['name'] = 'underline';
            $attributes['children_required'] = 'true';
        }
        else if ( ( $tagName === 'sub' || $tagName === 'sup' ) &amp;&amp; self::customTagIsEnabled( $tagName ) )
        {
            $name = 'custom';
            $attributes['name'] = $tagName;
            $attributes['children_required'] = 'true';
        }
        return $name;
    }

    /**
     * tagClassNamesCleanup
     * Used by init handlers, removes any oe/tinMCE/browser specific classes and trims the result.
     *
     * @static
     * @param string $className 'Dirty' class name as provided by TinyMCE
     * @return string Cleaned and trimmed class name
     */
    protected static function tagClassNamesCleanup( $className )
    {
        return trim( preg_replace( self::HTML_CLASS_REGEX, '', $className ) );
    }

    /**
     * parsingHandlerLiteral (parsing handler, pass 1)
     * parse content of literal tag so tags are threated like text.
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return bool|null
     */
    protected function parsingHandlerLiteral( $element, &amp;$param )
    {
        $ret = null;
        $data = $param[0];
        $pos = $param[1];

        $prePos = strpos( $data, '&lt;/pre&gt;', $pos );
        if ( $prePos === false )
            $prePos = strpos( $data, '&lt;/PRE&gt;', $pos );

        if ( $prePos === false )
            return $ret;

        $text = substr( $data, $pos, $prePos - $pos );

        $text = preg_replace( &quot;/^&lt;p.*?&gt;/i&quot;, '', $text );

        $text = preg_replace( &quot;/&lt;\/\s?p&gt;/i&quot;, '', $text );

        $text = preg_replace( &quot;/&lt;p.*?&gt;/i&quot;, &quot;\n\n&quot;, $text );
        $text = preg_replace( &quot;/&lt;\/?\s?br.*?&gt;/i&quot;, &quot;\n&quot;, $text );

        $text = $this-&gt;entitiesDecode( $text );
        $text = $this-&gt;convertNumericEntities( $text );

        $textNode = $this-&gt;Document-&gt;createTextNode( $text );
        $element-&gt;appendChild( $textNode );

        $param[1] = $prePos + strlen( '&lt;/pre&gt;' );
        $ret = false;

        return $ret;
    }

    /**
     * parsingHandlerParagraph (parsing handler, pass 1)
     * parse content of paragraph tag to fix empty paragraphs issues.
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return bool|null
     */
    protected function parsingHandlerParagraph( $element, &amp;$param )
    {
        $data = $param[0];
        $pos = $param[1];

        $prePos = strpos( $data, '&lt;/p&gt;', $pos );
        if ( $prePos === false )
            $prePos = strpos( $data, '&lt;/P&gt;', $pos );

        if ( $prePos === false )
            return null;

        $text = substr( $data, $pos, $prePos - $pos );
        // Fix empty paragraphs in Gecko (&lt;p&gt;&lt;br&gt;&lt;/p&gt;)
        if ( $text === '&lt;br&gt;' || $text === '&lt;BR&gt;' || $text === '&lt;br /&gt;' )
        {
            if ( !$this-&gt;XMLSchema-&gt;Schema['paragraph']['childrenRequired'] )
            {
                $textNode = $this-&gt;Document-&gt;createTextNode( $this-&gt;entitiesDecode( '&amp;nbsp;' ) );
                $element-&gt;appendChild( $textNode );
            }
        }
        // Fix empty paragraphs in IE  (&lt;P&gt;&amp;nbsp;&lt;/P&gt;)
        else if ( $text === '&amp;nbsp;' &amp;&amp; $this-&gt;XMLSchema-&gt;Schema['paragraph']['childrenRequired'] )
        {
            $parent = $element-&gt;parentNode;
            $parent-&gt;removeChild( $element );
        }

        return true;
    }

    /**
     * breakInlineFlow (parsing handler, pass 1)
     * handle flow around &lt;br&gt; tags, legazy from oe 4.x
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return bool|null
     */
    protected function breakInlineFlow( $element, &amp;$param )
    {
        // Breaks the flow of inline tags. Used for non-inline tags caught within inline.
        // Works for tags with no children only.
        $ret = null;
        $data =&amp; $param[0];
        $pos =&amp; $param[1];
        $tagBeginPos = $param[2];
        $parent = $element-&gt;parentNode;

        $wholeTagString = substr( $data, $tagBeginPos, $pos - $tagBeginPos );

        if ( $parent &amp;&amp;
            //!$this-&gt;XMLSchema-&gt;isInline( $element ) &amp;&amp;
            $this-&gt;XMLSchema-&gt;isInline( $parent ) //&amp;&amp;
            //!$this-&gt;XMLSchema-&gt;check( $parent, $element )
            )
        {
            $insertData = '';
            $currentParent = $parent;
            end( $this-&gt;ParentStack );
            do
            {
                $stackData = current( $this-&gt;ParentStack );
                $currentParentName = $stackData[0];
                $insertData .= '&lt;/' . $currentParentName . '&gt;';
                $currentParent = $currentParent-&gt;parentNode;
                prev( $this-&gt;ParentStack );
            }
            while ( $this-&gt;XMLSchema-&gt;isInline( $currentParent ) );

            $insertData .= $wholeTagString;

            $currentParent = $parent;
            end( $this-&gt;ParentStack );
            $appendData = '';
            do
            {
                $stackData = current( $this-&gt;ParentStack );
                $currentParentName = $stackData[0];
                $currentParentAttrString = '';
                if ( $stackData[2] )
                    $currentParentAttrString = ' ' . $stackData[2];
                $appendData = '&lt;' . $currentParentName . $currentParentAttrString . '&gt;' . $appendData;
                $currentParent = $currentParent-&gt;parentNode;
                prev( $this-&gt;ParentStack );
            }
            while ( $this-&gt;XMLSchema-&gt;isInline( $currentParent ) );

            $insertData .= $appendData;

            $data = $insertData . substr( $data, $pos );
            $pos = 0;
            $element = $parent-&gt;removeChild( $element );
            $ret = false;
        }

        return $ret;
    }

    /**
     * initHandlerCustom (init handler, pass 2 before childre tags)
     * seesm to be doing nothing
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return bool|null
     */
    protected function initHandlerCustom( $element, &amp;$params )
    {
        if ( $this-&gt;XMLSchema-&gt;isInline( $element ) )
            return null;

        self::elementStylesToAttribute( $element );
        return null;
    }

    /**
     * initHandlerHeader (init handler, pass 2 before childre tags)
     * sets anchor as attribute if setting is enabled
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return bool|null
     */
    protected function initHandlerHeader( $element, &amp;$params )
    {
        if ( $this-&gt;anchorAsAttribute )
        {
            $anchorElement = $element-&gt;firstChild;
            if ( $anchorElement-&gt;nodeName === 'anchor' )
            {
                $element-&gt;setAttribute( 'anchor_name', $anchorElement-&gt;getAttribute( 'name' ) );
                $anchorElement = $element-&gt;removeChild( $anchorElement );
            }
        }
        self::elementStylesToAttribute( $element );
        return null;
    }

    /**
     * transformStyles (init handler, pass 2 before childre tags)
     * tryes to convert css styles to attributes.
     *
     * @param DOMElement $element
     * @param array $params
     * @return null|array changes structure if it contains 'result' key
     */
    protected function transformStyles( $element, &amp;$params )
    {
        self::elementStylesToAttribute( $element );
        return null;
    }

    /**
     * appendLineParagraph (Structure handler, pass 2 after childre tags)
     * Structure handler for inline nodes.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function appendLineParagraph( $element, $newParent )
    {
        $ret = array();
        $parent = $element-&gt;parentNode;
        if ( !$parent instanceof DOMElement )
        {
            return $ret;
        }

        $parentName = $parent-&gt;nodeName;
        $next = $element-&gt;nextSibling;
        $newParentName = $newParent != null ? $newParent-&gt;nodeName : '';

        // Correct schema by adding &lt;line&gt; and &lt;paragraph&gt; tags.
        if ( $parentName === 'line' || $this-&gt;XMLSchema-&gt;isInline( $parent ) )
        {
            return $ret;
        }

        if ( $newParentName === 'line' )
        {
            $element = $parent-&gt;removeChild( $element );
            $newParent-&gt;appendChild( $element );
            $ret['result'] = $newParent;
        }
        elseif ( $parentName === 'paragraph' )
        {
            $newLine = $this-&gt;createAndPublishElement( 'line', $ret );
            $element = $parent-&gt;replaceChild( $newLine, $element );
            $newLine-&gt;appendChild( $element );
            $ret['result'] = $newLine;
        }
        elseif ( $newParentName === 'paragraph' )
        {
            $newLine = $this-&gt;createAndPublishElement( 'line', $ret );
            $element = $parent-&gt;removeChild( $element );
            $newParent-&gt;appendChild( $newLine );
            $newLine-&gt;appendChild( $element );
            $ret['result'] = $newLine;
        }
        elseif ( $this-&gt;XMLSchema-&gt;check( $parent, 'paragraph' ) )
        {
            $newLine = $this-&gt;createAndPublishElement( 'line', $ret );
            $newPara = $this-&gt;createAndPublishElement( 'paragraph', $ret );
            $parent-&gt;replaceChild( $newPara, $element );
            $newPara-&gt;appendChild( $newLine );
            $newLine-&gt;appendChild( $element );
            $ret['result'] = $newLine;
        }
        return $ret;
    }

    /**
     * structHandlerBr (Structure handler, pass 2 after childre tags)
     * Structure handler for temporary &lt;br&gt; elements
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerBr( $element, $newParent )
    {
        $ret = array();
        if ( $newParent &amp;&amp; $newParent-&gt;nodeName === 'line' )
        {
            $ret['result'] = $newParent-&gt;parentNode;
        }
        return $ret;
    }

    /**
     * appendParagraph (Structure handler, pass 2 after childre tags)
     * Structure handler for in-paragraph nodes.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function appendParagraph( $element, $newParent )
    {
        $ret = array();
        $parent = $element-&gt;parentNode;
        if ( !$parent )
            return $ret;

        $parentName = $parent-&gt;nodeName;

        if ( $parentName !== 'paragraph' )
        {
            if ( $newParent &amp;&amp; $newParent-&gt;nodeName === 'paragraph' )
            {
                $element = $parent-&gt;removeChild( $element );
                $newParent-&gt;appendChild( $element );
                $ret['result'] = $newParent;
                return $ret;
            }
            if ( $newParent
                &amp;&amp; $newParent-&gt;parentNode
                &amp;&amp; $newParent-&gt;parentNode-&gt;nodeName === 'paragraph' )
            {
                $para = $newParent-&gt;parentNode;
                $element = $parent-&gt;removeChild( $element );
                $para-&gt;appendChild( $element );
                $ret['result'] = $newParent-&gt;parentNode;
                return $ret;
            }

            if ( $this-&gt;XMLSchema-&gt;check( $parentName, 'paragraph' ) )
            {
                $newPara = $this-&gt;createAndPublishElement( 'paragraph', $ret );
                $parent-&gt;replaceChild( $newPara, $element );
                $newPara-&gt;appendChild( $element );
                $ret['result'] = $newPara;
            }
        }
        return $ret;
    }

    /**
     * structHandlerText (Structure handler, pass 2 after childre tags)
     * Structure handler for #text.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerText( $element, $newParent )
    {
        $ret = array();
        $parent = $element-&gt;parentNode;

        // Remove empty text elements
        if ( $element-&gt;textContent == '' )
        {
            $element = $parent-&gt;removeChild( $element );
            return $ret;
        }

        $ret = $this-&gt;appendLineParagraph( $element, $newParent );

        // Fix for italic/bold styles in Mozilla.
        $addStrong = $addEmph = null;
        $myParent = $element-&gt;parentNode;
        while ( $myParent )
        {
            $style = $myParent-&gt;getAttribute( 'style' );
            if ( $style &amp;&amp; $addStrong !== false &amp;&amp; strpos( $style, 'font-weight: bold;' ) !== false )
            {
                $addStrong = true;
            }
            if ( $style &amp;&amp; $addEmph !== false &amp;&amp; strpos( $style, 'font-style: italic;' ) !== false )
            {
                $addEmph = true;
            }

            if ( $myParent-&gt;nodeName === 'strong' )
            {
                $addStrong = false;
            }
            elseif ( $myParent-&gt;nodeName === 'emphasize' )
            {
                $addEmph = false;
            }
            elseif ( $myParent-&gt;nodeName === 'td'
                || $myParent-&gt;nodeName === 'th'
                || $myParent-&gt;nodeName === 'section' )
            {
                break;
            }
            $tmp = $myParent;
            $myParent = $tmp-&gt;parentNode;
        }

        $parent = $element-&gt;parentNode;
        if ( $addEmph === true )
        {
            $emph = $this-&gt;Document-&gt;createElement( 'emphasize' );
            $emph = $parent-&gt;insertBefore( $emph, $element );
            $element = $parent-&gt;removeChild( $element );
            $emph-&gt;appendChild( $element );
        }
        if ( $addStrong === true )
        {
            $strong = $this-&gt;Document-&gt;createElement( 'strong' );
            $strong = $parent-&gt;insertBefore( $strong, $element );
            $element = $parent-&gt;removeChild( $element );
            $strong-&gt;appendChild( $element );
        }

        // Left trim spaces:
        if ( $this-&gt;getOption( self::OPT_TRIM_SPACES ) )
        {
            $trim = false;
            $currentElement = $element;

            // Check if it is the first element in line
            do
            {
                if ( $currentElement-&gt;previousSibling )
                {
                    break;
                }

                $currentElement = $currentElement-&gt;parentNode;

                if ( $currentElement instanceof DOMElement &amp;&amp;
                    ( $currentElement-&gt;nodeName === 'line' ||
                    $currentElement-&gt;nodeName === 'paragraph' ) )
                {
                    $trim = true;
                    break;
                }

            } while ( $currentElement instanceof DOMElement );

            if ( $trim )
            {
                // Trim and remove if empty
                $element-&gt;textContent = ltrim( $element-&gt;textContent );
                if ( $element-&gt;textContent == '' )
                {
                    $parent = $element-&gt;parentNode;
                    $element = $parent-&gt;removeChild( $element );
                }
            }
        }

        return $ret;
    }

    /**
     * structHandlerHeader (Structure handler, pass 2 after childre tags)
     * Structure handler for header tag.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerHeader( $element, $newParent )
    {
        $ret = array();
        $parent = $element-&gt;parentNode;
        $level = $element-&gt;getAttribute( 'level' );
        if ( !$level )
        {
            $level = 1;
        }

        $element-&gt;removeAttribute( 'level' );
        if ( $level )
        {
            $sectionLevel = -1;
            $current = $element;
            while ( $current-&gt;parentNode )
            {
                $tmp = $current;
                $current = $tmp-&gt;parentNode;
                if ( $current-&gt;nodeName === 'section' )
                {
                    ++$sectionLevel;
                }
                elseif ( $current-&gt;nodeName === 'td' )
                {
                    ++$sectionLevel;
                    break;
                }
            }
            if ( $level &gt; $sectionLevel )
            {
                $newTempParent = $parent;
                for ( $i = $sectionLevel; $i &lt; $level; $i++ )
                {
                    $newSection = $this-&gt;Document-&gt;createElement( 'section' );
                    if ( $i == $sectionLevel )
                    {
                        $newSection = $newTempParent-&gt;insertBefore( $newSection, $element );
                    }
                    else
                    {
                        $newTempParent-&gt;appendChild( $newSection );
                    }
                    // Schema check
                    if ( !$this-&gt;processBySchemaTree( $newSection ) )
                    {
                        return $ret;
                    }
                    $newTempParent = $newSection;
                    unset( $newSection );
                }
                $elementToMove = $element;
                while ( $elementToMove &amp;&amp;
                    $elementToMove-&gt;nodeName !== 'section' )
                {
                    $next = $elementToMove-&gt;nextSibling;
                    $elementToMove = $parent-&gt;removeChild( $elementToMove );
                    $newTempParent-&gt;appendChild( $elementToMove );
                    $elementToMove = $next;

                    if ( !$elementToMove ||
                        ( $elementToMove-&gt;nodeName === 'header' &amp;&amp;
                        $elementToMove-&gt;getAttribute( 'level' ) &lt;= $level ) )
                        break;
                }
            }
            elseif ( $level &lt; $sectionLevel )
            {
                $newLevel = $sectionLevel + 1;
                $current = $element;
                while ( $level &lt; $newLevel )
                {
                    $tmp = $current;
                    $current = $tmp-&gt;parentNode;
                    if ( $current-&gt;nodeName === 'section' )
                        --$newLevel;
                }
                $elementToMove = $element;
                while ( $elementToMove &amp;&amp;
                    $elementToMove-&gt;nodeName !== 'section' )
                {
                    $next = $elementToMove-&gt;nextSibling;
                    $parent-&gt;removeChild( $elementToMove );
                    $current-&gt;appendChild( $elementToMove );
                    $elementToMove = $next;

                    if ( !$elementToMove ||
                        ( $elementToMove-&gt;nodeName === 'header' &amp;&amp;
                        $elementToMove-&gt;getAttribute( 'level' ) &lt;= $level ) )
                        break;
                }
            }
        }
        return $ret;
    }

    /**
     * structHandlerCustom (Structure handler, pass 2 after childre tags)
     * Structure handler for custom tag.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerCustom( $element, $newParent )
    {
        $ret = array();
        $isInline = $this-&gt;XMLSchema-&gt;isInline( $element );
        if ( $isInline )
        {
            $ret = $this-&gt;appendLineParagraph( $element, $newParent );

            $value = $element-&gt;getAttribute( 'value' );
            if ( $value )
            {
                $value = $this-&gt;washText( $value );
                $textNode = $this-&gt;Document-&gt;createTextNode( $value );
                $element-&gt;appendChild( $textNode );
            }
        }
        else
        {
            $ret = $this-&gt;appendParagraph( $element, $newParent );
        }
        return $ret;
    }

    /**
     * structHandlerLists (Structure handler, pass 2 after childre tags)
     * Structure handler for ul|ol tags.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerLists( $element, $newParent )
    {
        $ret = array();
        $parent = $element-&gt;parentNode;
        $parentName = $parent-&gt;nodeName;

        if ( $parentName === 'paragraph' )
            return $ret;

        // If we are inside a list
        if ( $parentName === 'ol' || $parentName === 'ul' )
        {
            // If previous 'li' doesn't exist, create it,
            // else append to the previous 'li' element.
            $prev = $element-&gt;previousSibling;
            if ( !$prev )
            {
                $li = $this-&gt;Document-&gt;createElement( 'li' );
                $li = $parent-&gt;insertBefore( $li, $element );
                $element = $parent-&gt;removeChild( $element );
                $li-&gt;appendChild( $element );
            }
            else
            {
                $lastChild = $prev-&gt;lastChild;
                if ( $lastChild-&gt;nodeName !== 'paragraph' )
                {
                    $para = $this-&gt;Document-&gt;createElement( 'paragraph' );
                    $element = $parent-&gt;removeChild( $element );
                    $prev-&gt;appendChild( $element );
                    $ret['result'] = $para;
                }
                else
                {
                    $element = $parent-&gt;removeChild( $element );
                    $lastChild-&gt;appendChild( $element );
                    $ret['result'] = $lastChild;
                }
                return $ret;
            }
        }
        else if ( $parentName === 'li' )
        {
            $prev = $element-&gt;previousSibling;
            if ( $prev )
            {
                $element = $parent-&gt;removeChild( $element );
                $prev-&gt;appendChild( $element );
                $ret['result'] = $prev;
                return $ret;
            }
        }
        $ret = $this-&gt;appendParagraph( $element, $newParent );
        return $ret;
    }

    /**
     * structHandlerParagraph (Structure handler, pass 2 after childre tags)
     * Structure handler for paragraph tag.
     *
     * @param DOMElement $element
     * @param DOMElement $newParent node that are going to become new parent.
     * @return array changes structure if it contains 'result' key
     */
    protected function structHandlerParagraph( $element, $newParent )
    {
        $ret = array();

        $parentNode = $element-&gt;parentNode;
        if ( $parentNode-&gt;nodeName === 'custom' &amp;&amp;
            !$this-&gt;XMLSchema-&gt;isInline( $parentNode ) &amp;&amp;
            $parentNode-&gt;childNodes-&gt;length === 1 &amp;&amp;
            $parentNode-&gt;getAttribute( 'name' ) === $element-&gt;textContent )
        {
            // removing the paragraph as it is there only to handle the custom
            // in the rich text editor
            $parentNode-&gt;removeAttribute( 'children_required' );
            $parentNode-&gt;removeChild( $element );
            return $ret;
        }

        if ( $element-&gt;getAttribute( 'ezparser-new-element' ) === 'true' &amp;&amp;
            !$element-&gt;hasChildren() )
        {
            $element = $element-&gt;parentNode-&gt;removeChild( $element );
            return $ret;
        }

        // Removes single line tag
        $line = $element-&gt;lastChild;
        if ( $element-&gt;childNodes-&gt;length == 1 &amp;&amp; $line-&gt;nodeName === 'line' )
        {
            $lineChildren = array();
            $lineChildNodes = $line-&gt;childNodes;
            foreach ( $lineChildNodes as $lineChildNode )
            {
                $lineChildren[] = $lineChildNode;
            }

            $line = $element-&gt;removeChild( $line );
            foreach ( $lineChildren as $lineChild )
            {
                $element-&gt;appendChild( $lineChild );
            }
        }

        return $ret;
    }

    /**
     * publishHandlerLink (Publish handler, pass 2 after schema validation)
     * Publish handler for link element, converts href to [object|node|link]_id.
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return null|array changes structure if it contains 'result' key
     */
    protected function publishHandlerLink( $element, &amp;$params )
    {
        $ret  = null;
        $href = $element-&gt;getAttribute( 'href' );
        if ( $href )
        {
            $objectID = false;
            if ( strpos( $href, 'ezobject' ) === 0
                &amp;&amp; preg_match( &quot;@^ezobject://([0-9]+)/?(#.+)?@i&quot;, $href, $matches ) )
            {
                $contentId = $matches[1];
                if ( isset( $matches[2] ) )
                    $anchorName = substr( $matches[2], 1 );
                $element-&gt;setAttribute( 'object_id', $contentId );

                // check if the referenced Content exists
                if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                {
                    if ( !$this-&gt;handler-&gt;checkContentById( $contentId ))
                    {
                        $this-&gt;Messages[] = &quot;Object '$contentId' does not exist.&quot;;
                    }
                }
            }

            /*
               * rfc2396: ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
               * ezdhtml: &quot;@^eznode://([^/#]+)/?(#[^/]*)?/?@i&quot;
            */
            elseif ( strpos( $href, 'eznode' ) === 0
                &amp;&amp; preg_match( &quot;@^eznode://([^#]+)(#.+)?@i&quot;, $href, $matches ) )
            {
                $nodePath = trim( $matches[1], '/' );
                if ( isset( $matches[2] ) )
                    $anchorName = substr( $matches[2], 1 );

                // Location by id
                if ( is_numeric( $nodePath ) )
                {
                    $locationId = $nodePath;
                    if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                    {
                        $location = $this-&gt;handler-&gt;getLocationById( $locationId );
                        if ( $location === false )
                        {
                            $this-&gt;Messages[] = &quot;Location $locationId does not exist&quot;;
                        }
                        else
                        {
                            $contentId = $location-&gt;contentId;
                        }
                    }
                }
                // Location by path
                else
                {
                    if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                    {
                        $location = $this-&gt;handler-&gt;getLocationByPath( $nodePath );
                        if ( $location === false )
                        {
                            $this-&gt;Messages[] = &quot;Node &amp;apos;$nodePath&amp;apos; does not exist.&quot;;
                        }
                        else
                        {
                            $locationId = $location-&gt;id;
                            $contentId = $location-&gt;contentId;
                        }
                        $element-&gt;setAttribute( 'show_path', 'true' );
                    }
                }

                if ( isset( $locationId ) &amp;&amp; $locationId )
                {
                    $element-&gt;setAttribute( 'node_id', $locationId );
                }
            }
            elseif ( strpos( $href, '#' ) === 0 )
            {
                $anchorName = substr( $href, 1 );
            }
            else
            {
                $temp = explode( '#', $href );
                $url = $temp[0];
                if ( isset( $temp[1] ) )
                {
                    $anchorName = $temp[1];
                }

                if ( $url )
                {
                    // Protection from XSS attack
                    if ( preg_match( &quot;/^(java|vb)script:.*/i&quot; , $url ) )
                    {
                        $this-&gt;isInputValid = false;
                        $this-&gt;Messages[] = &quot;Using scripts in links is not allowed, '$url' has been removed&quot;;
                        $element-&gt;removeAttribute( 'href' );
                        return $ret;
                    }

                    // Check mail address validity following RFC 5322 and RFC 5321
                    if ( preg_match( &quot;/^mailto:([^.][a-z0-9!#\$%&amp;'*+-\/=?`{|}~^]+@([a-z0-9.-]+))/i&quot; , $url, $mailAddr ) )
                    {
                        /* @todo re-implement
                        if ( !eZMail::validate( $mailAddr[1] ) )
                        {
                            $this-&gt;isInputValid = false;
                            if ( $this-&gt;errorLevel &gt;= 0 )
                                $this-&gt;Messages[] = ezpI18n::tr( 'kernel/classes/datatypes/ezxmltext',
                                                            &quot;Invalid e-mail address: '%1'&quot;,
                                                            false,
                                                            array( $mailAddr[1] ) );
                            $element-&gt;removeAttribute( 'href' );
                            return $ret;
                        }*/

                    }
                    // Store urlID instead of href
                    if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                    {
                        $url   = str_replace(array('&amp;amp;', '%28', '%29'), array('&amp;', '(', ')'), $url );
                        $url = $this-&gt;handler-&gt;registerUrl( $url );

                        if ( $url !== false )
                        {
                            if ( !in_array( $url-&gt;id, $this-&gt;urlIDArray ) )
                                $this-&gt;urlIDArray[] = $url-&gt;id;

                            $element-&gt;setAttribute( 'url_id', $url-&gt;id );
                        }
                    }
                }
            }

            if ( $objectID &amp;&amp; !in_array( $objectID, $this-&gt;linkedObjectIDArray ) )
                $this-&gt;linkedObjectIDArray[] = $objectID;

            if ( isset( $anchorName ) &amp;&amp; $anchorName )
                $element-&gt;setAttribute( 'anchor_name', $anchorName );
        }
        return $ret;
    }

    /**
     * publishHandlerEmbed (Publish handler, pass 2 after schema validation)
     * Publish handler for embed element, convert id to [object|node]_id parameter,
     * fixes align=middle value (if embed was image) and tries to map css to attributes
     *
     * @param DOMElement $element
     * @param array $param parameters for xml element
     * @return null|array changes structure if it contains 'result' key
     */
    protected function publishHandlerEmbed( $element, &amp;$params )
    {
        $ID = $element-&gt;getAttribute( 'id' );
        if ( $ID )
        {
            $objectID = false;
            $element-&gt;removeAttribute( 'id' );
            if ( strpos( $ID, 'eZObject_' ) !== false )
            {
                if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                {
                    $objectID = substr( $ID, strpos( $ID, '_' ) + 1 );
                    $element-&gt;setAttribute( 'object_id', $objectID );
                    $object = $this-&gt;handler-&gt;getContentById( $objectID );
                    if ( !$object )
                    {
                        if ( !in_array( $objectID, $this-&gt;deletedEmbeddedObjectIDArray ) )
                            $this-&gt;deletedEmbeddedObjectIDArray[] = $objectID;
                    }
                    elseif ( $object-&gt;attribute('status') == eZContentObject::STATUS_ARCHIVED )
                    {
                        $this-&gt;thrashedEmbeddedObjectIDArray[] = $objectID;
                    }
                }
            }
            else if ( strpos( $ID, 'eZNode_' ) !== false )
            {
                if ( $this-&gt;getOption( self::OPT_CHECK_EXTERNAL_DATA ) )
                {
                    $nodeID = substr( $ID, strpos( $ID, '_' ) + 1 );
                    $element-&gt;setAttribute( 'node_id', $nodeID );

                    $node = $this-&gt;handler-&gt;getLocationById( $nodeID );
                    if ( $node )
                        $objectID = $node-&gt;contentId;
                    else if ( !in_array( $nodeID, $this-&gt;deletedEmbeddedNodeIDArray ) )
                        $this-&gt;deletedEmbeddedNodeIDArray[] = $nodeID;
                }
            }

            if ( $objectID &amp;&amp; !in_array( $objectID, $this-&gt;embeddedObjectIDArray ) )
            {
                $this-&gt;embeddedObjectIDArray[] = $objectID;
            }
        }
        $align = $element-&gt;getAttribute( 'align' );
        if ( $align &amp;&amp; $align === 'middle' )
        {
            $element-&gt;setAttribute( 'align', 'center' );
        }
        return null;
    }

    /**
     * processAttributesBySchema
     * Parses customattributes attribute and splits it into actual
     * custom: xml attributes, passes processing of normal attributes
     * to parent class.
     *
     * @param DOMElement $element
     */
    protected function processAttributesBySchema( $element )
    {
        // custom attributes conversion
        $attr = $element-&gt;getAttribute( 'customattributes' );
        if ( $attr )
        {
            $attrArray = explode( 'attribute_separation', $attr );
            foreach ( $attrArray as $attr )
            {
                if ( $attr !== '' &amp;&amp; strpos( $attr, '|' ) !== false )
                {
                    list( $attrName, $attrValue ) = explode( '|', $attr );
                    $element-&gt;setAttributeNS( 'http://ez.no/namespaces/ezpublish3/custom/',
                                              'custom:' . $attrName,
                                              $attrValue );
                }
            }
        }

        parent::processAttributesBySchema( $element );
    }

    public function getEmbeddedObjectIDArray()
    {
        return $this-&gt;embeddedObjectIDArray;
    }

    /**
     * Get list over currently deleted embeded objects, nodes and (optionally) objects in trash
     *
     * @param bool $includeTrash
     * @return array
     */
    public function getDeletedEmbedIDArray( $includeTrash = false )
    {
        $arr = array();
        if ( $this-&gt;deletedEmbeddedNodeIDArray )
            $arr['nodes'] = $this-&gt;deletedEmbeddedNodeIDArray;
        if ( $this-&gt;deletedEmbeddedObjectIDArray )
            $arr['objects'] = $this-&gt;deletedEmbeddedObjectIDArray;
        if ( $includeTrash &amp;&amp; $this-&gt;thrashedEmbeddedObjectIDArray )
            $arr['trash'] = $this-&gt;thrashedEmbeddedObjectIDArray;
        return $arr;
    }

    /**
     * Check if a custom tag is enabled
     *
     * @param string $name
     * @return bool
     */
    public static function customTagIsEnabled( $name )
    {
        if ( self::$customTagList === null )
        {
            $ini = Configuration::getInstance( 'content' );
            self::$customTagList = $ini-&gt;get( 'CustomTagSettings', 'AvailableCustomTags', array() );
        }
        return in_array( $name, self::$customTagList );
    }

    /**
     * Trying to convert CSS rules to XML attributes
     * (for the case of pasting from external source)
     *
     * @param DOMElement $element
     */
    protected static function elementStylesToAttribute( DOMElement $element )
    {
        $styleString = $element-&gt;getAttribute( 'style' );
        if ( $styleString )
        {
            $styleArray = explode( ';', $styleString );
            foreach ( $styleArray as $style )
            {
                if ( !$style )
                    continue;

                list( $name, $value ) = explode( ':', $style );
                $name  = trim( $name );
                $value = trim( $value );

                if ( $name === 'float' || $name === 'text-align' )
                    $name = 'align';

                if ( $name )
                    $element-&gt;setAttribute( $name, $value );
            }
        }
    }
}
?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>