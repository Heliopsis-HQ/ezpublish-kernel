<html>
    <head>
        <script
            type="text/javascript"
            src="../../../../../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../../../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../../../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../../../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * File containing the \ezp\Content\FieldType\XmlText\Input\Parser\Base
 *
 * @copyright Copyright (C) 1999-2012 eZ Systems AS. All rights reserved.
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
 * @version //autogentag//
 */

namespace ezp\Content\FieldType\XmlText\Input\Parser;

use DOMDocument, DOMElement, DOMNode, DOMText,
    ezp\Base\Configuration,
    ezp\Content\FieldType\XmlText\Schema as XmlSchema,
    ezp\Content\FieldType\XmlText\Input\Handler as InputHandler,
    ezp\Base\Exception\BadConfiguration;

/**
 * Base class for the input parser.
 * The goal of the parser is XML/HTML analyzing, fixing and transforming.
 * The input is processed in 2 passes:
 *  - 1st pass: Parsing input, check for syntax errors, build DOM tree.
 *  - 2nd pass: Walking through DOM tree, checking validity by XML schema,
 *              calling tag handlers to transform the tree.
 *
 * Both passes are controlled by the arrays described bellow and user handler functions.
 */
abstract class Base
{
    /**
     * Error types constants
     */
    const ERROR_NONE = 0;
    const ERROR_SYNTAX = 4;
    const ERROR_SCHEMA = 8;
    const ERROR_DATA = 16;
    const ERROR_ALL = 28; // 4+8+16

    /**
     * Parser options constants, to be used with setOption
     * @var string
     * @see setOption()
     */
    const OPT_VALIDATE_ERROR_LEVEL = 'ValidateErrorLevel';
    const OPT_DETECT_ERROR_LEVEL = 'DetectErrorLevel';
    const OPT_REMOVE_DEFAULT_ATTRS = 'RemoveDefaultAttrs';
    const OPT_PARSE_LINE_BREAKS = 'ParseLineBreaks';
    const OPT_EZ_PUBLISH_VERSION = 'eZPublishVersion';
    const OPT_TRIM_SPACES = 'TrimSpaces';
    const OPT_ALLOW_MULTIPLE_SPACES = 'AllowMultipleSpaces';
    const OPT_ALLOW_NUMERIC_ENTITIES = 'AllowNumericEntities';
    const OPT_STRICT_HEADERS = 'StrictHeaders';
    const OPT_DOM_DOCUMENT_CLASS = 'DOMDocumentClass';
    const OPT_CHECK_EXTERNAL_DATA = 'checkExternalData';

    /** Properties of elements that come from the input.
     *
     * Each array element describes a tag that comes from the input. Arrays index is
     * a tag's name. Each element is an array that may contain the following members:
     * - name: a string representing a new name of the tag
     * - nameHandler: a name of the function that returns new tag name.
     *                Function format: function tagNameHandler( $tagName, &amp;$attributes )
     *                If none of those elements are defined the original tag's name is used.
     * - noChildren: boolean value that determines if this tag could have child tags. Default value is false.
     *
     * &lt;code&gt;
     * $InputTags = array(
     *     'original-name' =&gt; array( 'name' =&gt; 'new-name' ),
     *     'original-name2' =&gt; array( 'nameHandler' =&gt; 'tagNameHandler',
     *                                'noChildren' =&gt; true ),
     * );
     * &lt;/code&gt;
     */
    protected $InputTags = array();

    /**
    * Properties of elements that are produced in the output.
    *
    * Each array element describes a tag presented in the output. Arrays index is
    * a tag's name. Each element is an array that may contain the following members:
    * - parsingHandler: &quot;Parsing handler&quot; called at parse pass 1 before processing tag's children.
    * - initHandler: &quot;Init handler&quot; called at pass 2 before proccessing tag's children.
    * - structHandler: &quot;Structure handler&quot; called at pass 2 after proccessing tag's children,
    *                  but before schema validity check. It can be used to implement structure
    *                  transformations.
    * - publishHandler: &quot;Publish handler&quot; called at pass 2 after schema validity check, so it is called
    *                  in case the element has it's guaranteed place in the DOM tree.
    * - attributes: an array that describes attributes transformations. Array's index is the
    *              original name of an attribute, and the value is the new name.
    * - requiredInputAttributes: attributes that are required in the input tag. If they are not presented
    *                            it raises invalid input flag.
    *
    * &lt;code&gt;
    * public $OutputTags = array(
    *    'custom'    =&gt; array( 'parsingHandler' =&gt; 'parsingHandlerCustom',
    *                          'initHandler' =&gt; 'initHandlerCustom',
    *                          'structHandler' =&gt; 'structHandlerCustom',
    *                          'publishHandler' =&gt; 'publishHandlerCustom',
    *                          'attributes' =&gt; array( 'title' =&gt; 'name' ) ),
    * );
    * @var array
.   */
    protected $OutputTags = array();

    /**
     * List of XmlText namespaces
     * @var array
     */
    protected $Namespaces = array( 'image' =&gt; 'http://ez.no/namespaces/ezpublish3/image/',
                                   'xhtml' =&gt; 'http://ez.no/namespaces/ezpublish3/xhtml/',
                                   'custom' =&gt; 'http://ez.no/namespaces/ezpublish3/custom/',
                                   'tmp' =&gt; 'http://ez.no/namespaces/ezpublish3/temporary/' );

    /**
     * Parser options list
     * @var mixed[string]
     */
    protected $options = array(
        'ValidateErrorLevel' =&gt; self::ERROR_NONE,
        'DetectErrorLevel' =&gt; self::ERROR_NONE,
        'RemoveDefaultAttrs' =&gt; false,
        'ParseLineBreaks' =&gt; false,
        'eZPublishVersion' =&gt; 4.6,
        'TrimSpaces' =&gt; false,
        'AllowMultipleSpaces' =&gt; false,
        'AllowNumericEntities' =&gt; false,
        'StrictHeaders' =&gt; false,
        'DOMDocumentClass' =&gt; 'DOMDocument',
        'checkExternalData' =&gt; true,
    );

    /**
     * XmlSchema object
     * @var \ezp\Content\FieldType\XmlText\Schema
     */
    protected $XMLSchema;

    /**
     * DOM document object
     * @var \DOMDocument
     */
    protected $Document = null;

    /**
     * Processing messages
     * @var string[]
     * @see getMessages()
     */
    protected $Messages = array();

    /**
     * Parent nodes stack
     * @var string[]
     */
    protected $ParentStack = array();

    /**
     * Boolean holding the validity status of the input string
     * @var boolean
     * @see isInputValid()
     */
    protected $isInputValid = true;

    /**
     * Boolean used to interrupt the process between steps
     * @var boolean
     */
    protected $QuitProcess = false;

    /**
     * Array of Url objects ids
     * @var integer[]
     */
    protected $urlIDArray = array();

    /**
     * Array of related Content objects id
     * @var integer[]
     */
    protected $relatedObjectIDArray = array();

    /**
     * Array of linked Content objects id
     * @var integer[]
     */
    protected $linkedObjectIDArray = array();

    // needed for self-embedding protection
    protected $contentObjectID = 0;

    /**
     * Input handler
     * @var \ezp\Content\FieldType\XmlText\Input\Handler
     */
    protected $handler;

    /**
     * Construct a new Parser
     */
    public function __construct()
    {
        $this-&gt;XMLSchema = XmlSchema::getInstance();

        // $this-&gt;setOption( self::OPT_EZ_PUBLISH_VERSION, eZPublishSDK::majorVersion() + eZPublishSDK::minorVersion() * 0.1 );

        $xmlConfig = Configuration::getInstance( 'ezxml' );

        $this-&gt;setOption( self::OPT_TRIM_SPACES, $xmlConfig-&gt;get( 'InputSettings', 'TrimSpaces', 'true' ) == 'true' ? true : false );
        $this-&gt;setOption( self::OPT_ALLOW_MULTIPLE_SPACES, $xmlConfig-&gt;get( 'InputSettings', 'AllowMultipleSpaces', 'false' ) == 'true' ? true : false );
        $this-&gt;setOption( self::OPT_ALLOW_NUMERIC_ENTITIES, $xmlConfig-&gt;get( 'InputSettings', 'AllowNumericEntities', 'false' ) == 'true' ? true : false );

        self::setOption( self::OPT_STRICT_HEADERS, Configuration::getInstance( &quot;content&quot; )-&gt;get( 'header', 'UseStrictHeaderRule', 'false' ) == 'true' ? true : false );
    }

    /**
     * Sets the input handler for the parser to $handler
     * @param \ezp\Content\FieldType\XmlText\Input\Handler $handler
     */
    public function setHandler( InputHandler $handler )
    {
        $this-&gt;handler = $handler;
    }

    /**
     * Sets the parser option $option to $value
     * @param string $option One of self::OPT_*
     * @param mixed $value
     * @throws \ezp\Base\Exception\BadConfiguration If the option is unknown or the value incorrect
     */
    public function setOption( $option, $value )
    {
        if ( !$this-&gt;optionExists( $option ) )
        {
            throw new BadConfiguration( &quot;Unknown option $option&quot; );
        }
        // @todo Add control over value
        $this-&gt;options[$option] = $value;
    }

    /**
     * Gets the parser option $option
     * @param string $option One of self::OPT_*
     * @throws \ezp\Base\Exception\BadConfiguration If the option is unknown or the value incorrect
     */
    public function getOption( $option )
    {
        if ( !$this-&gt;optionExists( $option ) )
        {
            throw new BadConfiguration( &quot;Unknown option $option&quot; );
        }
        return $this-&gt;options[$option];
    }

    /**
     * Check if $option exists
     *
     * @param string $option
     * @return bool
     */
    private function optionExists( $option )
    {
        return isset( $this-&gt;options[$option] );
    }

    /**
     * Processes $text
     * @param string $text
     * @param bool $createRootNode
     * @return DOMDocument
     */
    public function process( $text, $createRootNode = true )
    {
        $text = str_replace( &quot;\r&quot;, '', $text );
        $text = str_replace( &quot;\t&quot;, ' ', $text );
        // replace unicode chars that will break the XML validity
        // see http://www.w3.org/TR/REC-xml/#charsets
        $text = preg_replace( '/[^\x{0009}\x{000a}\x{000d}\x{0020}-\x{D7FF}\x{E000}-\x{FFFD}]+/u', ' ', $text, -1, $count );
        if ( $count &gt; 0 )
        {
            $this-&gt;messages[] = &quot;$count invalid character(s) have been found and replaced by a space&quot;;
        }
        if ( !$this-&gt;getOption( self::OPT_PARSE_LINE_BREAKS ) )
        {
            $text = str_replace( &quot;\n&quot;, '', $text);
        }

        $this-&gt;Document = $this-&gt;createDomDocument();

        // Perform pass 1
        // Parsing the source string
        $this-&gt;performPass1( $text );

        $this-&gt;Document-&gt;formatOutput = true;
        // $debug = eZDebugSetting::isConditionTrue( 'kernel-datatype-ezxmltext', eZDebug::LEVEL_DEBUG );
        /*if ( $debug )
        {
            // eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(), eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext', 'XML after pass 1' ) );
        }*/

        if ( $this-&gt;QuitProcess )
        {
            return false;
        }

        // Perform pass 2
        $this-&gt;performPass2();

        $this-&gt;Document-&gt;formatOutput = true;
        /*if ( $debug )
        {
            // eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(), eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext', 'XML after pass 2' ) );
        }*/

        if ( $this-&gt;QuitProcess )
        {
            return false;
        }

        return $this-&gt;Document;
    }

    /**
     * Creates the DOMDocument object holding the XML text
     * @param bool $createRootNode wether or not to create the root &lt;section&gt; node
     * @return \DOMDocument
     */
    protected function createDomDocument( $createRootNode = true )
    {
        $domDocumentClass = $this-&gt;getOption( self::OPT_DOM_DOCUMENT_CLASS );
        $domDocument = new $domDocumentClass( '1.0', 'utf-8' );

        // Creating root section with namespaces definitions
        if ( $createRootNode )
        {
            $mainSection = $domDocument-&gt;createElement( 'section' );
            $domDocument-&gt;appendChild( $mainSection );
            foreach ( array( 'image', 'xhtml', 'custom' ) as $prefix )
            {
                $mainSection-&gt;setAttributeNS( 'http://www.w3.org/2000/xmlns/', 'xmlns:' . $prefix, $this-&gt;Namespaces[$prefix] );
            }
        }
        return $domDocument;
    }

    /*
     * Pass 1: Parsing the source HTML string.
     */
    private function performPass1( &amp;$data )
    {
        $ret = true;
        $pos = 0;

        if ( $this-&gt;Document-&gt;documentElement )
        {
            do
            {
                $this-&gt;parseTag( $data, $pos, $this-&gt;Document-&gt;documentElement );
                if ( $this-&gt;QuitProcess )
                {
                    $ret = false;
                    break;
                }

            }
            while ( $pos &lt; strlen( $data ) );
        }
        else
        {
            $tmp = null;
            $this-&gt;parseTag( $data, $pos, $tmp );
            if ( $this-&gt;QuitProcess )
            {
                $ret = false;
            }
        }
        return $ret;
    }

    private function parseTag( &amp;$data, &amp;$pos, &amp;$parent )
    {
        // Find tag, determine it's type, name and attributes.
        $initialPos = $pos;

        if ( $pos &gt;= strlen( $data ) )
        {
            return true;
        }
        $tagBeginPos = strpos( $data, '&lt;', $pos );

        if ( $this-&gt;getOption( self::OPT_PARSE_LINE_BREAKS ) )
        {
            // Regard line break as a start tag position
            $lineBreakPos = strpos( $data, &quot;\n&quot;, $pos );
            if ( $lineBreakPos !== false )
            {
                $tagBeginPos = $tagBeginPos === false ? $lineBreakPos : min( $tagBeginPos, $lineBreakPos );
            }
        }

        $tagName = '';
        $attributes = null;
        // If it doesn't begin with '&lt;' then its a text node.
        if ( $tagBeginPos != $pos || $tagBeginPos === false )
        {
            $pos = $initialPos;
            $tagName = $newTagName = '#text';
            $noChildren = true;

            if ( !$tagBeginPos )
            {
                $tagBeginPos = strlen( $data );
            }

            $textContent = substr( $data, $pos, $tagBeginPos - $pos );

            $textContent = $this-&gt;washText( $textContent );

            $pos = $tagBeginPos;
            if ( $textContent === '' )
            {
                return false;
            }
        }
        // Process closing tag.
        elseif ( $data[$tagBeginPos] == '&lt;' &amp;&amp; $tagBeginPos + 1 &lt; strlen( $data ) &amp;&amp;
                 $data[$tagBeginPos + 1] == '/' )
        {
            $tagEndPos = strpos( $data, '&gt;', $tagBeginPos + 1 );
            if ( $tagEndPos === false )
            {
                $pos = $tagBeginPos + 1;

                $this-&gt;handleError( self::ERROR_SYNTAX, 'Wrong closing tag 1' );
                return false;
            }

            $pos = $tagEndPos + 1;
            $closedTagName = strtolower( trim( substr( $data, $tagBeginPos + 2, $tagEndPos - $tagBeginPos - 2 ) ) );

            // Find matching tag in ParentStack array
            $firstLoop = true;
            for ( $i = count( $this-&gt;ParentStack ) - 1; $i &gt;= 0; $i-- )
            {
                $parentNames = $this-&gt;ParentStack[$i];
                if ( $parentNames[0] == $closedTagName )
                {
                    array_pop( $this-&gt;ParentStack );
                    if ( !$firstLoop )
                    {
                        $pos = $tagBeginPos;
                        return true;
                    }
                    // If newTagName was '' we don't break children loop
                    elseif ( $parentNames[1] !== '' )
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                $firstLoop = false;
            }

            $this-&gt;handleError( self::ERROR_SYNTAX, &quot;Wrong closing tag 2: &amp;lt;/$closedTagName&amp;gt;.&quot; );

            return false;
        }
        // Insert &lt;br/&gt; instead of linebreaks
        elseif ( $this-&gt;getOption( self::OPT_PARSE_LINE_BREAKS ) &amp;&amp; $data[$tagBeginPos] == &quot;\n&quot; )
        {
            $newTagName = 'br';
            $noChildren = true;
            $pos = $tagBeginPos + 1;
        }
        //  Regular tag: get tag's name and attributes.
        else
        {
            $tagEndPos = strpos( $data, '&gt;', $tagBeginPos );
            if ( $tagEndPos === false )
            {
                $pos = $tagBeginPos + 1;

                $this-&gt;handleError( self::ERROR_SYNTAX, 'Wrong opening tag' );
                return false;
            }

            $pos = $tagEndPos + 1;
            $tagString = substr( $data, $tagBeginPos + 1, $tagEndPos - $tagBeginPos - 1 );
            // Check for final backslash
            $noChildren = substr( $tagString, -1, 1 ) == '/' ? true : false;
            // Remove final backslash and spaces
            $tagString = preg_replace( &quot;/\s*\/$/&quot;, &quot;&quot;, $tagString );

            $firstSpacePos = strpos( $tagString, ' ' );
            if ( $firstSpacePos === false )
            {
                $tagName = strtolower( trim( $tagString ) );
                $attributeString = '';
            }
            else
            {
                $tagName = strtolower( substr( $tagString, 0, $firstSpacePos ) );
                $attributeString = substr( $tagString, $firstSpacePos + 1 );
                $attributeString = trim( $attributeString );
                // Parse attribute string
                if ( $attributeString )
                {
                    $attributes = $this-&gt;parseAttributes( $attributeString );
                }
            }

            // Determine tag's name
            if ( isset( $this-&gt;InputTags[$tagName] ) )
            {
                $thisInputTag = $this-&gt;InputTags[$tagName];

                if ( isset( $thisInputTag['name'] ) )
                {
                    $newTagName = $thisInputTag['name'];
                }
                else
                {
                    $newTagName = $this-&gt;callInputHandler( 'nameHandler', $tagName, $attributes );
                }
            }
            else
            {
                // @todo -cBase DO use XMLSchema
                $newTagName = $tagName;
                if ( $this-&gt;XMLSchema-&gt;exists( $tagName ) )
                {
                    $newTagName = $tagName;
                }
                else
                {
                    $this-&gt;handleError( self::ERROR_SYNTAX, &quot;Unknown tag: &amp;lt;$tagName&amp;gt;.&quot; );
                    return false;
                }
            }

            // Check 'noChildren' property
            if ( isset( $thisInputTag['noChildren'] ) )
            {
                $noChildren = true;
            }

            $thisOutputTag = isset( $this-&gt;OutputTags[$newTagName] ) ? $this-&gt;OutputTags[$newTagName] : null;

            // Implementation of 'autoCloseOn' rule ( Handling of unclosed tags, ex.: &lt;p&gt;, &lt;li&gt; )
            if ( isset( $thisOutputTag['autoCloseOn'] ) &amp;&amp;
                 $parent &amp;&amp;
                 $parent-&gt;parentNode instanceof DOMElement &amp;&amp;
                 in_array( $parent-&gt;nodeName, $thisOutputTag['autoCloseOn'] ) )
            {
                // Wrong nesting: auto-close parent and try to re-parse this tag at higher level
                array_pop( $this-&gt;ParentStack );
                $pos = $tagBeginPos;
                return true;
            }

            // Append to parent stack
            if ( !$noChildren &amp;&amp; $newTagName !== false )
            {
                $this-&gt;ParentStack[] = array( $tagName, $newTagName, $attributeString );
            }

            if ( !$newTagName )
            {
                // If $newTagName is an empty string then it's not a error
                if ( $newTagName === false )
                    $this-&gt;handleError( self::ERROR_SYNTAX, &quot;Can't convert tag's name: &amp;lt;$tagName&amp;gt;.&quot; );

                return false;
            }

            // wordmatch.ini support
            if ( $attributeString )
            {
                $attributes = $this-&gt;wordMatchSupport( $newTagName, $attributes, $attributeString );
            }
        }

        // Create text or normal node.
        if ( $newTagName == '#text' )
        {
            $element = $this-&gt;Document-&gt;createTextNode( $textContent );
        }
        else
        {
            $element = $this-&gt;Document-&gt;createElement( $newTagName );
        }

        if ( $attributes )
        {
            $this-&gt;setAttributes( $element, $attributes );
        }

        // Append element as a child or set it as root if there is no parent.
        if ( $parent )
        {
            $parent-&gt;appendChild( $element );
        }
        else
        {
            $this-&gt;Document-&gt;appendChild( $element );
        }

        $params = array();
        $params[] =&amp; $data;
        $params[] =&amp; $pos;
        $params[] =&amp; $tagBeginPos;
        $result = $this-&gt;callOutputHandler( 'parsingHandler', $element, $params );

        if ( $result === false )
        {
            // This tag is already parsed in handler
            if ( !$noChildren )
            {
                array_pop( $this-&gt;ParentStack );
            }
            return false;
        }

        if ( $this-&gt;QuitProcess )
        {
            return false;
        }

        // Process children
        if ( !$noChildren )
        {
            do
            {
                $parseResult = $this-&gt;parseTag( $data, $pos, $element );
                if ( $this-&gt;QuitProcess )
                {
                    return false;
                }
            }
            while ( $parseResult !== true );
        }

        return false;
    }

    /**
     * Helper functions for pass 1
     * @return array
     */
    private function parseAttributes( $attributeString )
    {
        $attributes = array();
        // Valid characters for XML attributes
        // @see http://www.w3.org/TR/xml/#NT-Name
        $nameStartChar = ':A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\x{2FF}\\x{370}-\\x{37D}\\x{37F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}';
        if (
            preg_match_all(
                &quot;/\s+([$nameStartChar][$nameStartChar\-.0-9\\xB7\\x{0300}-\\x{036F}\\x{203F}-\\x{2040}]*)\s*=\s*(?:(?:\&quot;([^\&quot;]+?)\&quot;)|(?:'([^']+?)')|(?: *([^\&quot;'\s]+)\s*))/u&quot;,
                &quot; &quot; . $attributeString,
                $attributeArray,
                PREG_SET_ORDER
            )
        ) {
            foreach ( $attributeArray as $attribute )
            {
                // Value will always be at the last position
                $value = trim( array_pop( $attribute ) );
                if ( !empty( $value ) )
                {
                    $attributes[strtolower( $attribute[1] )] = $value;
                }
            }
        }

        return $attributes;
    }

    /**
     * Sets attributes from $attributes on $element
     * @param DOMElement $element
     * @param array $attributes
     */
    private function setAttributes( DOMElement $element, $attributes )
    {
        $thisOutputTag = $this-&gt;OutputTags[$element-&gt;nodeName];

        foreach ( $attributes as $key =&gt; $value )
        {
            // Convert attribute names
            if ( isset( $thisOutputTag['attributes'] ) &amp;&amp;
                 isset( $thisOutputTag['attributes'][$key] ) )
            {
                $qualifiedName = $thisOutputTag['attributes'][$key];
            }
            else
            {
                $qualifiedName = $key;
            }

            // Filter classes
            if ( $qualifiedName == 'class' )
            {
                $classesList = $this-&gt;XMLSchema-&gt;getClassesList( $element-&gt;nodeName );
                if ( !in_array( $value, $classesList ) )
                {
                    $this-&gt;handleError( self::ERROR_DATA, &quot;Class '$value' is not allowed for element &amp;lt;$element-&gt;nodeName&amp;gt; (check content.ini).&quot;);
                    continue;
                }
            }

            // Create attribute nodes
            if ( $qualifiedName )
            {
                if ( strpos( $qualifiedName, ':' ) )
                {
                    list( $prefix, $name ) = explode( ':', $qualifiedName );
                    if ( isset( $this-&gt;Namespaces[$prefix] ) )
                    {
                        $URI = $this-&gt;Namespaces[$prefix];
                        $element-&gt;setAttributeNS( $URI, $qualifiedName, $value );
                    }
                    else
                    {
                        // eZDebug::writeWarning( &quot;No namespace defined for prefix '$prefix'.&quot;, 'eZXML input parser' );
                    }
                }
                else
                {
                    $element-&gt;setAttribute( $qualifiedName, $value );
                }
            }
        }

        // Check for required attrs are present
        if ( isset( $this-&gt;OutputTags[$element-&gt;nodeName]['requiredInputAttributes'] ) )
        {
            foreach ( $this-&gt;OutputTags[$element-&gt;nodeName]['requiredInputAttributes'] as $reqAttrName )
            {
                $presented = false;
                foreach ( $attributes as $key =&gt; $value )
                {
                    if ( $key == $reqAttrName )
                    {
                        $presented = true;
                        break;
                    }
                }
                if ( !$presented )
                {
                    $this-&gt;handleError( self::ERROR_SCHEMA, &quot;Required attribute '$reqAttrName' is not presented in tag &amp;lt;$element-&gt;nodeName&amp;gt;.&quot; );
                }
            }
        }
    }

    private function washText( $textContent )
    {
        $textContent = $this-&gt;entitiesDecode( $textContent );

        if ( !$this-&gt;getOption( self::OPT_ALLOW_NUMERIC_ENTITIES ) )
        {
            $textContent = $this-&gt;convertNumericEntities( $textContent );
        }

        if ( !$this-&gt;getOption( self::OPT_ALLOW_MULTIPLE_SPACES ) )
        {
            $textContent = preg_replace( &quot;/ {2,}/&quot;, &quot; &quot;, $textContent );
        }

        return $textContent;
    }

    private function entitiesDecode( $text )
    {
        $text = str_replace( '&amp;#039;', &quot;'&quot;, $text );

        $text = str_replace( '&amp;gt;', '&gt;', $text );
        $text = str_replace( '&amp;lt;', '&lt;', $text );
        $text = str_replace( '&amp;apos;', &quot;'&quot;, $text );
        $text = str_replace( '&amp;quot;', '&quot;', $text );
        $text = str_replace( '&amp;amp;', '&amp;', $text );
        return $text;
    }

    private function convertNumericEntities( $text )
    {
        if ( strlen( $text ) &lt; 4 )
        {
            return $text;
        }

        return $text;
        // Convert other HTML entities to the current charset characters.
        /*$codec = eZTextCodec::instance( 'unicode', false );
        $pos = 0;
        $domString = &quot;&quot;;
        while ( $pos &lt; strlen( $text ) - 1 )
        {
            $startPos = $pos;
            while ( !( $text[$pos] == '&amp;' &amp;&amp; $text[$pos + 1] == '#' ) &amp;&amp; $pos &lt; strlen( $text ) - 1 )
            {
                $pos++;
            }

            $domString .= substr( $text, $startPos, $pos - $startPos );

            if ( $pos &lt; strlen( $text ) - 1 )
            {
                $endPos = strpos( $text, ';', $pos + 2 );
                if ( $endPos === false )
                {
                    $convertedText .= '&amp;#';
                    $pos += 2;
                    continue;
                }

                $code = substr( $text, $pos + 2, $endPos - ( $pos + 2 ) );
                $char = $codec-&gt;convertString( array( $code ) );

                $pos = $endPos + 1;
                $domString .= $char;
            }
            else
            {
                $domString .= substr( $text, $pos, 2 );
            }
        }*/
        return $domString;
    }

    private function wordMatchSupport( $newTagName, $attributes, $attributeString )
    {
        $cfg = Configuration::getInstance( 'wordmatch' );
        if ( $cfg-&gt;has( $newTagName, 'MatchString' ) )
        {
            $matchArray = $cfg-&gt;get( $newTagName, 'MatchString' );
            if ( $matchArray )
            {
                foreach ( array_keys( $matchArray ) as $key )
                {
                    $matchString = $matchArray[$key];
                    if (  preg_match( &quot;/$matchString/i&quot;, $attributeString ) )
                    {
                        $attributes['class'] = $key;
                        unset( $attributes['style'] );
                    }
                }
            }
        }
        return $attributes;
    }

    private function performPass2()
    {
        $tmp = null;

        $this-&gt;processSubtree( $this-&gt;Document-&gt;documentElement, $tmp );
    }

    private function processSubtree( DOMNode $element, &amp;$lastHandlerResult )
    {
        $ret = null;
        $tmp = null;

        // Call &quot;Init handler&quot;
        $this-&gt;callOutputHandler( 'initHandler', $element, $tmp );

        $debug = false;

        // Process children
        if ( $element-&gt;hasChildNodes() )
        {
            // Make another copy of children to save primary structure
            $childNodes = $element-&gt;childNodes;
            $childrenCount = $childNodes-&gt;length;

            // we can not loop directly over the childNodes property, because this will change while we are working on it's parent's children
            $children = array();
            foreach ( $childNodes as $childNode )
            {
                $children[] = $childNode;
            }

            $lastResult = null;
            $newElements = array();
            foreach ( $children as $child )
            {
                if ( $debug )
                {
                    // eZDebug::writeDebug( 'processing children, current child: ' . $child-&gt;nodeName, eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext', __METHOD__ ) );
                }

                $childReturn = $this-&gt;processSubtree( $child, $lastResult );

                unset( $lastResult );
                if ( isset( $childReturn['result'] ) )
                {
                    if ( $debug )
                    {
                        // eZDebug::writeDebug( 'return result is set for child ' . $child-&gt;nodeName, eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext', __METHOD__ ) );
                    }

                    $lastResult = $childReturn['result'];
                }

                if ( isset( $childReturn['new_elements'] ) )
                {
                    $newElements = array_merge( $newElements, $childReturn['new_elements'] );
                }

                if ( $this-&gt;QuitProcess )
                {
                    return $ret;
                }
            }

            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'XML before processNewElements for element ' . $element-&gt;nodeName ) );
            }*/

            // process elements created in children handlers
            $this-&gt;processNewElements( $newElements );

            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'XML after processNewElements for element ' . $element-&gt;nodeName ) );
            }*/
        }

        // Call &quot;Structure handler&quot;
        if ( $debug )
        {
            /*eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                 eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                              'XML before callOutputHandler structHandler for element ' . $element-&gt;nodeName ) );*/
        }

        $ret = $this-&gt;callOutputHandler( 'structHandler', $element, $lastHandlerResult );

        /*if ( $debug )
        {
            eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                 eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                              'XML after callOutputHandler structHandler for element ' . $element-&gt;nodeName ) );
            eZDebug::writeDebug( $ret,
                                 eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                              'return value of callOutputHandler structHandler for element ' . $element-&gt;nodeName ) );
        }*/

        // Process by schema (check if element is allowed to exist)
        if ( !$this-&gt;processBySchemaPresence( $element ) )
        {
            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'XML after failed processBySchemaPresence for element ' . $element-&gt;nodeName ) );
            }*/
            return $ret;
        }

        /*if ( $debug )
        {
            eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                 eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                              'XML after processBySchemaPresence for element ' . $element-&gt;nodeName ) );
        }*/

        // Process by schema (check place in the tree)
        if ( !$this-&gt;processBySchemaTree( $element ) )
        {
            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'XML after failed processBySchemaTree for element ' . $element-&gt;nodeName ) );
            }*/
            return $ret;
        }

        /*if ( $debug )
        {
            eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                 eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                              'XML after processBySchemaTree for element ' . $element-&gt;nodeName ) );
        }*/

        $tmp = null;
        // Call &quot;Publish handler&quot;
        $this-&gt;callOutputHandler( 'publishHandler', $element, $tmp );

        // Process attributes according to the schema
        if ( $element-&gt;hasAttributes() )
        {
            if ( !$this-&gt;XMLSchema-&gt;hasAttributes( $element ) )
            {
                eZXMLInputParser::removeAllAttributes( $element );
            }
            else
            {
                $this-&gt;processAttributesBySchema( $element );
            }
        }
        return $ret;
    }

    /**
     * Removes all attributes from $element
     * @param DOMElement $element
     */
    private function removeAllAttributes( DOMElement $element )
    {
        $attribs = $element-&gt;attributes;
        for ( $i = $attribs-&gt;length - 1; $i &gt;= 0; $i-- )
        {
            $element-&gt;removeAttributeNode( $attribs-&gt;item( $i ) );
        }
    }

    /**
     * Check if the element is allowed to exist in this document and remove it if not.
     * @param DOMElement $element
     */
    private function processBySchemaPresence( DOMNode $element )
    {
        $parent = $element-&gt;parentNode;
        if ( $parent instanceof DOMElement )
        {
            // If this is a foreign element, remove it
            if ( !$this-&gt;XMLSchema-&gt;exists( $element ) )
            {
                if ( $element-&gt;nodeName == 'custom' )
                {
                    $this-&gt;handleError( self::ERROR_SCHEMA, &quot;Custom tag '&quot;.$element-&gt;getAttribute( 'name' ).&quot;' is not allowed.&quot; );
                }
                $element = $parent-&gt;removeChild( $element );
                return false;
            }

            // Delete if children required and no children
            // If this is an auto-added element, then do not throw error

            if ( $element-&gt;nodeType == XML_ELEMENT_NODE &amp;&amp; ( $this-&gt;XMLSchema-&gt;childrenRequired( $element ) || $element-&gt;getAttribute( 'children_required' ) )
                 &amp;&amp; !$element-&gt;hasChildNodes() )
            {
                $element = $parent-&gt;removeChild( $element );
                if ( !$element-&gt;getAttributeNS( 'http://ez.no/namespaces/ezpublish3/temporary/', 'new-element' ) )
                {
                    $this-&gt;handleError( self::ERROR_SCHEMA, &quot;&amp;lt;$element-&gt;nodeName&amp;gt; tag can't be empty.&quot; );
                    return false;
                }
            }
        }
        // TODO: break processing of any node that doesn't have parent
        //       and is not a root node.
        elseif ( $element-&gt;nodeName != 'section' )
        {
            return false;
        }
        return true;
    }

    /**
     * Check that $element has a correct position in the tree and fix it if not.
     * @param DOMElement $element
     */
    protected function processBySchemaTree( $element )
    {
        $parent = $element-&gt;parentNode;

        if ( $parent instanceof DOMElement )
        {
            $schemaCheckResult = $this-&gt;XMLSchema-&gt;check( $parent, $element );
            if ( !$schemaCheckResult )
            {
                if ( $schemaCheckResult === false )
                {
                    // Remove indenting spaces
                    if ( $element-&gt;nodeType == XML_TEXT_NODE &amp;&amp; !trim( $element-&gt;textContent ) )
                    {
                        $element = $parent-&gt;removeChild( $element );
                        return false;
                    }

                    $elementName = $element-&gt;nodeType == XML_ELEMENT_NODE ? '&amp;lt;' . $element-&gt;nodeName . '&amp;gt;' : $element-&gt;nodeName;
                    throw new \Exception( &quot;'$elementName' is not allowed to be a child of &amp;lt;$parent-&gt;nodeName&amp;gt;.&quot; );
                    $this-&gt;handleError( self::ERROR_SCHEMA, &quot;'$elementName' is not allowed to be a child of &amp;lt;$parent-&gt;nodeName&amp;gt;.&quot; );
                }
                $this-&gt;fixSubtree( $element, $element );
                return false;
            }
        }
        // TODO: break processing of any node that doesn't have parent
        //       and is not a root node.
        elseif ( $element-&gt;nodeName != 'section' )
        {
            return false;
        }
        return true;
    }

    /**
     * Removes nodes that don't match schema (recursively)
     */
    private function fixSubtree( $element, $mainChild )
    {
        $parent = $element-&gt;parentNode;
        $mainParent = $mainChild-&gt;parentNode;
        while ( $element-&gt;hasChildNodes() )
        {
            $child = $element-&gt;firstChild;

            $child = $element-&gt;removeChild( $child );
            $child = $mainParent-&gt;insertBefore( $child, $mainChild );

            if ( !$this-&gt;XMLSchema-&gt;check( $mainParent, $child ) )
            {
                $this-&gt;fixSubtree( $child, $mainChild );
            }
        }
        $parent-&gt;removeChild( $element );
    }

    private function processAttributesBySchema( $element )
    {
        // Remove attributes that don't match schema
        $schemaAttributes = $this-&gt;XMLSchema-&gt;attributes( $element );
        $schemaCustomAttributes = $this-&gt;XMLSchema-&gt;customAttributes( $element );

        $attributes = $element-&gt;attributes;

        for ( $i = $attributes-&gt;length - 1; $i &gt;=0; $i-- )
        {
            $attr = $attributes-&gt;item( $i );
            if ( $attr-&gt;prefix == 'tmp' )
            {
                $element-&gt;removeAttributeNode( $attr );
                continue;
            }

            $allowed = false;
            $removeAttr = false;

            $fullName = $attr-&gt;prefix ? $attr-&gt;prefix . ':' . $attr-&gt;localName : $attr-&gt;nodeName;

            // check for allowed custom attributes (3.9)
            if ( $attr-&gt;prefix == 'custom' &amp;&amp; in_array( $attr-&gt;localName, $schemaCustomAttributes ) )
            {
                $allowed = true;
            }
            else
            {
                if ( in_array( $fullName, $schemaAttributes ) )
                {
                   $allowed = true;
                }
                elseif ( in_array( $fullName, $schemaCustomAttributes ) )
                {
                    // add 'custom' prefix if it is not given
                    $allowed = true;
                    $removeAttr = true;
                    $element-&gt;setAttributeNS( $this-&gt;Namespaces['custom'], 'custom:' . $fullName, $attr-&gt;value );
                }
            }

            if ( !$allowed )
            {
                $removeAttr = true;
                $this-&gt;handleError( self::ERROR_SCHEMA, &quot;Attribute '$fullName' is not allowed in &amp;lt;$element-&gt;nodeName&amp;gt; element.&quot;);
            }
            elseif ( $this-&gt;getOption( self::OPT_REMOVE_DEFAULT_ATTRS ) )
            {
                // Remove attributes having default values
                $default = $this-&gt;XMLSchema-&gt;attrDefaultValue( $element-&gt;nodeName, $fullName );
                if ( $attr-&gt;value == $default )
                {
                    $removeAttr = true;
                }
            }

            if ( $removeAttr )
            {
                $element-&gt;removeAttributeNode( $attr );
            }
        }
    }

    protected function callInputHandler( $handlerName, $tagName, &amp;$attributes )
    {
        $result = null;
        $thisInputTag = $this-&gt;InputTags[$tagName];
        if ( isset( $thisInputTag[$handlerName] ) )
        {
            if ( is_callable( array( $this, $thisInputTag[$handlerName] ) ) )
            {
                $result = call_user_func_array( array( $this, $thisInputTag[$handlerName] ),
                                                array( $tagName, &amp;$attributes ) );
            }
            else
            {
                // @todo -cBase Exception
                // eZDebug::writeWarning( &quot;'$handlerName' input handler for tag &lt;$tagName&gt; doesn't exist: '&quot; . $thisInputTag[$handlerName] . &quot;'.&quot;, 'eZXML input parser' );
            }
        }
        return $result;
    }

    protected function callOutputHandler( $handlerName, $element, &amp;$params )
    {
        $result = null;
        $thisOutputTag = $this-&gt;OutputTags[$element-&gt;nodeName];
        if ( isset( $thisOutputTag[$handlerName] ) )
        {
            if ( is_callable( array( $this, $thisOutputTag[$handlerName] ) ) )
            {
                $result = call_user_func_array( array( $this, $thisOutputTag[$handlerName] ),
                                                array( $element, &amp;$params ) );
            }
            else
            {
                throw new BadConfiguration( &quot;outputHandler $handlerName ({$thisOutputTag[$handlerName]}) for $element-&gt;nodeName&quot; );
            }
        }

        return $result;
    }

    /**
     * Creates new element from $elementName and adds it to array for further post-processing.
     *
     * Use this function if you need to process newly created element (check it by schema
     * and call 'structure' and 'publish' handlers)
     *
     * @return DOMElement the created element
     */
    protected function createAndPublishElement( $elementName, &amp;$ret )
    {
        $element = $this-&gt;Document-&gt;createElement( $elementName );
        $element-&gt;setAttributeNS( 'http://ez.no/namespaces/ezpublish3/temporary/', 'tmp:new-element', 'true' );

        if ( !isset( $ret['new_elements'] ) )
        {
            $ret['new_elements'] = array();
        }

        $ret['new_elements'][] = $element;
        return $element;
    }

    private function processNewElements( $createdElements )
    {
        $debug = false; // eZDebugSetting::isConditionTrue( 'kernel-datatype-ezxmltext', eZDebug::LEVEL_DEBUG );
        // Call handlers for newly created elements
        foreach ( $createdElements as $element )
        {
            /*if ( $debug )
            {
                eZDebug::writeDebug( 'processing new element ' . $element-&gt;nodeName, eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext' ) );
            }*/

            $tmp = null;
            if ( !$this-&gt;processBySchemaPresence( $element ) )
            {
                /*if ( $debug )
                {
                    eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                         eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                      'xml string after failed processBySchemaPresence for new element ' . $element-&gt;nodeName ) );
                }*/
                continue;
            }

            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'xml string after processBySchemaPresence for new element ' . $element-&gt;nodeName ) );
            }*/


            // Call &quot;Structure handler&quot;
            $this-&gt;callOutputHandler( 'structHandler', $element, $tmp );

            if ( !$this-&gt;processBySchemaTree( $element ) )
            {
                /*if ( $debug )
                {
                    eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                         eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                      'xml string after failed processBySchemaTree for new element ' . $element-&gt;nodeName ) );
                }*/
                continue;
            }

            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'xml string after processBySchemaTree for new element ' . $element-&gt;nodeName ) );
            }*/


            $tmp2 = null;
            // Call &quot;Publish handler&quot;
            $this-&gt;callOutputHandler( 'publishHandler', $element, $tmp2 );

            /*if ( $debug )
            {
                eZDebug::writeDebug( $this-&gt;Document-&gt;saveXML(),
                                     eZDebugSetting::changeLabel( 'kernel-datatype-ezxmltext',
                                                                  'xml string after callOutputHandler publishHandler for new element ' . $element-&gt;nodeName ) );
            }*/

            // Process attributes according to the schema
            if ( $element-&gt;hasAttributes() )
            {
                if ( !$this-&gt;XMLSchema-&gt;hasAttributes( $element ) )
                {
                    self::removeAllAttributes( $element );
                }
                else
                {
                    $this-&gt;processAttributesBySchema( $element );
                }
            }
        }
    }

    /**
     * Returns the XML processing messages
     * @return array
     */
    public function getMessages()
    {
        return $this-&gt;Messages;
    }

    /**
     * Returns the validity status of the processed XML String
     * @return bool
     */
    public function isValid()
    {
        return $this-&gt;isInputValid;
    }

    protected function handleError( $type, $message )
    {
        if ( $type &amp; $this-&gt;getOption( self::OPT_DETECT_ERROR_LEVEL ) )
        {
            $this-&gt;IsInputValid = false;
            if ( $message )
            {
                $this-&gt;Messages[] = $message;
            }
        }

        if ( $type &amp; $this-&gt;getOption( self::OPT_VALIDATE_ERROR_LEVEL ) )
        {
            $this-&gt;IsInputValid = false;
            $this-&gt;QuitProcess = true;
        }
    }

    public function getRelatedContentIdArray()
    {
        return $this-&gt;relatedObjectIDArray;
    }

    public function getLinkedContentIdArray()
    {
        return $this-&gt;linkedObjectIDArray;
    }

    public function getUrlIdArray()
    {
        return $this-&gt;urlIDArray;
    }
}
?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>